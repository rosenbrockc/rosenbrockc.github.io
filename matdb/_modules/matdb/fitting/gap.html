
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>matdb.fitting.gap &#8212; matdb 0.0.4 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">matdb 0.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for matdb.fitting.gap</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implements classes and methods for performing a GAP fit over a</span>
<span class="sd">database defined in the YAML specification file.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">matdb</span> <span class="k">import</span> <span class="n">msg</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">quippy</span>

<div class="viewcode-block" id="update_nbody"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.update_nbody">[docs]</a><span class="k">def</span> <span class="nf">update_nbody</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds the usual n-body settings to the specified dictionary. This function</span>
<span class="sd">    *alters* the `settings` parameter.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings (dict): key-value pairs that are accepted by the GAP</span>
<span class="sd">          `distance_Nb` potential type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">usuals</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;compact_clusters&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;sparse_method&quot;</span><span class="p">:</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="s2">&quot;covariance_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ARD_SE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;theta_uniform&quot;</span><span class="p">:</span> <span class="mf">1.0</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">usuals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span></div>

<div class="viewcode-block" id="update_soap"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.update_soap">[docs]</a><span class="k">def</span> <span class="nf">update_soap</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds the usual soap settings to the specified dictionary. This function</span>
<span class="sd">    *alters* the `settings` parameter.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings (dict): key-value pairs that are accepted by the GAP</span>
<span class="sd">          `soap` potential type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">usuals</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;cutoff_transition_width&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="s2">&quot;atom_sigma&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="s2">&quot;zeta&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;sparse_method&quot;</span><span class="p">:</span> <span class="s1">&#39;cur_points&#39;</span><span class="p">,</span>
        <span class="s2">&quot;covariance_type&quot;</span><span class="p">:</span> <span class="s1">&#39;dot_product&#39;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">usuals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span></div>

<div class="viewcode-block" id="dict_to_str"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.dict_to_str">[docs]</a><span class="k">def</span> <span class="nf">dict_to_str</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts the specified dictionary of QUIP-compatible settings into a</span>
<span class="sd">    single string.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings (dict): key-value pairs that are recognized settings by QUIP</span>
<span class="sd">          for descriptors, teach_sparse, eval, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">settings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">v</span>

        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="gpfile_name"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.gpfile_name">[docs]</a><span class="k">def</span> <span class="nf">gpfile_name</span><span class="p">(</span><span class="n">gaps</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;gp&quot;</span><span class="p">,</span> <span class="n">hessfit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the expected gp file name for the specified set of GAPs.</span>

<span class="sd">    Args:</span>
<span class="sd">        gaps (list): of `int` body sizes for the potentials. SOAP has value 10</span>
<span class="sd">          by arbitrary definition.</span>
<span class="sd">        hessfit (bool): when True, the fit is being performed using Hessian</span>
<span class="sd">          fitting.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: gp_{nbody_list}(_{soap})?.xml if valid potentials are in the list;</span>
<span class="sd">        otherwise None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">soap</span> <span class="o">=</span> <span class="s2">&quot;_soap&quot;</span> <span class="k">if</span> <span class="mi">10</span> <span class="ow">in</span> <span class="n">gaps</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">nbody</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gaps</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;b&#39;</span>
    <span class="n">hess</span> <span class="o">=</span> <span class="s2">&quot;h&quot;</span> <span class="k">if</span> <span class="n">hessfit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">nbody</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">_</span><span class="si">{}{}</span><span class="s2">.xml&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">nbody</span><span class="p">,</span> <span class="n">soap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<span class="k">def</span> <span class="nf">_extract_pots</span><span class="p">(</span><span class="n">settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determines the configuration settings for each of the GAPs or other</span>
<span class="sd">    potential pieces specified in the `settings` dictionary.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings (dict): keys are GAP types (e.g., 2-body, 3-body, SOAP); values</span>
<span class="sd">          are `dict` with key-value pairs for the `teach_sparse` command.</span>

<span class="sd">    Returns:</span>

<span class="sd">        tuple: `(gaps, others)` where gaps is a :class:`collections.OrderedDict`</span>
<span class="sd">        of GAP names in the obvious order (2b, 3b, Nb, SOAP) with keys being</span>
<span class="sd">        integer ids representing the n-body order (SOAP: 10) and values being</span>
<span class="sd">        the string key in `settings`; others represents any other settings&#39; keys</span>
<span class="sd">        in the dictionary that are not recognized as parts of potentials.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>
    <span class="n">gaps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">others</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#Before we set the other attributes, let&#39;s first see what potentials are</span>
    <span class="c1">#present in the settings dictonary.</span>
    <span class="kn">from</span> <span class="nn">fnmatch</span> <span class="k">import</span> <span class="n">fnmatch</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;soap&quot;</span><span class="p">:</span>
            <span class="c1">#The 10 here is arbitrary; we will never create a 10-body</span>
            <span class="c1">#potential using distance_Nb.</span>
            <span class="n">gaps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;soap&quot;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">fnmatch</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="s2">&quot;*body&quot;</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gaps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">others</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">ogap</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">gaps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ogap</span><span class="p">,</span> <span class="n">others</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_max_gap</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">hessfit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the list of maximally executed GAPs as part of the iterative</span>
<span class="sd">    training scheme.</span>

<span class="sd">    Args:</span>
<span class="sd">        root (str): root directory in which to search for potential files.</span>
<span class="sd">        hessfit (bool): when True, look for the maximally executed GAP that was</span>
<span class="sd">          trained using hessian fitting.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: of `int` n-body codes (SOAP = 10) defining the progress so far in</span>
<span class="sd">        the overall fitting scheme.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">matdb.utility</span> <span class="k">import</span> <span class="n">chdir</span>
    <span class="kn">from</span> <span class="nn">glob</span> <span class="k">import</span> <span class="n">glob</span>
    <span class="n">nbmax</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="n">chdir</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;gph*.xml&quot;</span> <span class="k">if</span> <span class="n">hessfit</span> <span class="k">else</span> <span class="s2">&quot;gp*.xml&quot;</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">soap</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">for</span> <span class="n">potname</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
            <span class="n">potstr</span> <span class="o">=</span> <span class="n">potname</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">potstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">nbstr</span><span class="p">,</span> <span class="n">soapstr</span> <span class="o">=</span> <span class="n">parts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">nbstr</span> <span class="o">=</span> <span class="n">parts</span>
                <span class="n">soapstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="c1">#It is possible that we are doing a soap-only fit, in which case the</span>
            <span class="c1">#n-body integer will be missing.</span>
            <span class="n">nbmax</span> <span class="o">=</span> <span class="n">nbstr</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nbmax</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">nbmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbmax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nbmax</span> <span class="o">=</span> <span class="mi">0</span>
                
            <span class="k">if</span> <span class="n">nbmax</span> <span class="o">&gt;</span> <span class="n">nmax</span><span class="p">:</span>
                <span class="n">nmax</span> <span class="o">=</span> <span class="n">nbmax</span>
            <span class="k">if</span> <span class="n">soapstr</span> <span class="o">==</span> <span class="s2">&quot;soap&quot;</span><span class="p">:</span>
                <span class="n">soap</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">nbmax</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">xgaps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xgaps</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">if</span> <span class="n">soap</span><span class="p">:</span>
        <span class="n">xgaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xgaps</span>

<span class="k">def</span> <span class="nf">_n_neighbors</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the *average* number of nearest or next-nearest neighbors</span>
<span class="sd">    depending on the specified reference cutoff.</span>

<span class="sd">    Args:</span>
<span class="sd">        atoms (quippy.Atoms): seed configuration to use for getting neighbors.</span>
<span class="sd">        cutoff (float): reference cutoff radius around each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">acopy</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">acopy</span><span class="o">.</span><span class="n">set_cutoff</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>
    <span class="n">acopy</span><span class="o">.</span><span class="n">calc_connect</span><span class="p">()</span>
    
    <span class="n">neighs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">acopy</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">neighb</span> <span class="ow">in</span> <span class="n">acopy</span><span class="o">.</span><span class="n">connect</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">neighb</span><span class="o">.</span><span class="n">distance</span>
            <span class="n">deltain</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">dist</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-5</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">neighs</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">deltain</span><span class="p">):</span>
                <span class="n">neighs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">shells</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">neighs</span><span class="p">)</span>

    <span class="c1">#Determine whether we should use nearest or next-nearest neighbors.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">ncut</span> <span class="o">=</span> <span class="n">shells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ncut</span> <span class="o">=</span> <span class="n">shells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ncut</span> <span class="o">+=</span> <span class="mf">1e-4</span>
    
    <span class="n">acopy</span><span class="o">.</span><span class="n">set_cutoff</span><span class="p">(</span><span class="n">ncut</span><span class="p">)</span>
    <span class="n">acopy</span><span class="o">.</span><span class="n">calc_connect</span><span class="p">()</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">acopy</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
        <span class="n">neighs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acopy</span><span class="o">.</span><span class="n">n_neighbours</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">neighs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_rescale_2body</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the appropriate scaling factor for the RMS error of a 2-body</span>
<span class="sd">    potential. </span>

<span class="sd">    Args:</span>
<span class="sd">        atoms (quippy.Atoms): seed configuration to use for getting neighbors.</span>
<span class="sd">        settings (dict): key-value pairs used to configure the 2-body potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_n_neighbors</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">])</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">okay</span><span class="p">(</span><span class="s2">&quot;2-body: scaling by </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">n</span>

<span class="k">def</span> <span class="nf">_rescale_3body</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the appropriate scaling factor for the RMS error of a 3-body</span>
<span class="sd">    potential. </span>

<span class="sd">    Args:</span>
<span class="sd">        atoms (quippy.Atoms): seed configuration to use for getting neighbors.</span>
<span class="sd">        settings (dict): key-value pairs used to configure the 3-body potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#First, get the number of nearest neighbors in the cutoff.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_n_neighbors</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;cutoff&quot;</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">okay</span><span class="p">(</span><span class="s2">&quot;3-body: scaling by </span><span class="si">{}</span><span class="s2"> (from </span><span class="si">{}</span><span class="s2"> neighbors).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="GAPTrainer"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.GAPTrainer">[docs]</a><span class="k">class</span> <span class="nc">GAPTrainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements a simple wrapper around the GAP training functionality that</span>
<span class="sd">    can integrate with the methods of the `database` sub-package.</span>

<span class="sd">    .. note:: Creating GAP potentials is a multi-fitting procedure. For a</span>
<span class="sd">      `2 + 3 + ...` potential, we first need to fit the 2-body, and then (based</span>
<span class="sd">      on its errors), configure the fitting for the 2 + 3 potential. The results</span>
<span class="sd">      from the previous fit are used to configure the fitting that includes the</span>
<span class="sd">      next, higher-order potential type. As a result, the fits take longer as</span>
<span class="sd">      more complexity is included *and* the previous, lower-body terms have to</span>
<span class="sd">      be refit as part of the total many-body potential.</span>

<span class="sd">    Args:</span>
<span class="sd">        gap (list): of `str` that are either `*body` for the n-body potentials</span>
<span class="sd">          or `soap`. This determines which potentials are included as part of</span>
<span class="sd">          the fit.</span>
<span class="sd">        db (matdb.database.controller.Controller): database controller whose</span>
<span class="sd">          data will be used to train the potentials.</span>
<span class="sd">        gp_file (str): name of the output GAP potential file. Defaults to</span>
<span class="sd">          `gp_nbody_soap.xml` where `nbody` is a list of the n-body potentials</span>
<span class="sd">          included  and `soap` is included if it was part of the fit.</span>
<span class="sd">        e0 (float): reference &quot;zero&quot; for the potential energy surface.</span>
<span class="sd">        default_sigma (list): of `float` specifies the expected variance in the</span>
<span class="sd">          energy, force, virial, and hessian respectively. It should have length</span>
<span class="sd">          4. Defaults to `[0.001, 0.01, 1.0, 1.0]`.</span>
<span class="sd">        sparse_jitter (float): jitter added to the matrices before inversion to</span>
<span class="sd">          help improve the condition number.</span>
<span class="sd">        split (float): percentage of the available data to use for</span>
<span class="sd">          training (vs. validation).</span>
<span class="sd">        root (str): root directory for the entire alloy database</span>
<span class="sd">          (i.e., corresponding to a single YAML specification file).</span>
<span class="sd">        execution (dict): settings needed to configure the jobfile for running</span>
<span class="sd">          the GAP fit.</span>
<span class="sd">        configs (list): of `str` configuration ids from the database</span>
<span class="sd">          that should be included in the training and validation.</span>
<span class="sd">        kwargs (dict): additional parameters accepted by `teach_sparse` or a</span>
<span class="sd">          `*body` or `soap` dict that defines the settings for each particular</span>
<span class="sd">          GAP.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        ogap (collections.OrderedDict): keys are integer n-body values</span>
<span class="sd">          (SOAP=10), values are the [&quot;2-body&quot;, &quot;3-body&quot;, ..., &quot;soap&quot;] string</span>
<span class="sd">          values.</span>
<span class="sd">        gap (list): of `str` that are either `*body` for the n-body potentials</span>
<span class="sd">          or `soap`. This determines which potentials are included as part of</span>
<span class="sd">          the fit.</span>
<span class="sd">        db (matdb.database.controller.Controller): database controller whose</span>
<span class="sd">          data will be used to train the potentials.</span>
<span class="sd">        gp_file (str): name of the output GAP potential file. Defaults to</span>
<span class="sd">          `gp_nbody_soap.xml` where `nbody` is a list of the n-body potentials</span>
<span class="sd">          included  and `soap` is included if it was part of the fit.</span>
<span class="sd">        name (str): name of the folder in which all the fitting for this trainer</span>
<span class="sd">          takes place; defaults to :attr:`gp_file` without the &quot;.xml&quot;</span>
<span class="sd">          extension.</span>
<span class="sd">        root (str): root directory that this trainer operates in.</span>
<span class="sd">        e0 (float): reference &quot;zero&quot; for the potential energy surface.</span>
<span class="sd">        default_sigma (list): of `float` specifies the expected variance in the</span>
<span class="sd">          energy, force, virial, and hessian respectively. It should have length</span>
<span class="sd">          4. Defaults to `[0.001, 0.01, 0.1, 0.1]`.</span>
<span class="sd">        sparse_jitter (float): jitter added to the matrices before inversion to</span>
<span class="sd">          help improve the condition number.</span>
<span class="sd">        split (float): percentage of the available data to use for</span>
<span class="sd">          training (vs. validation).</span>
<span class="sd">        execution (dict): settings needed to configure the jobfile for running</span>
<span class="sd">          the GAP fit.</span>
<span class="sd">        teach_sparse (dict): key-value pairs that are passed directly to</span>
<span class="sd">          `teach_sparse` that are not in [&quot;e0&quot;, &quot;default_sigma&quot;,</span>
<span class="sd">          &quot;sparse_jitter&quot;].</span>
<span class="sd">        gaps (dict): keys are one of [&quot;2body&quot;, &quot;3body&quot;, ..., &quot;soap&quot;] describing</span>
<span class="sd">          the kind of potential. Values are the actual potential key-value</span>
<span class="sd">          pairs for configuring that particular GAP.</span>
<span class="sd">        seeds (dict): keys are database names in the controller; values are</span>
<span class="sd">          copies of the seed configuration :class:`quippy.Atoms` objects in each</span>
<span class="sd">          of those databases, with hessian and force information attached.</span>
<span class="sd">        state (list): of `int` GAP n-body codes in :attr:`gap` indicating the current</span>
<span class="sd">          progress/state in the multi-chain fitting process. This value iterates</span>
<span class="sd">          over each of the GAPs in turn, adding one extra one each time the</span>
<span class="sd">          previous set has finished executing.</span>
<span class="sd">        hessfit (bool): when True, the trainer is performing a hessian-based fit</span>
<span class="sd">          over the configurations (as opposed to using the entire configuration</span>
<span class="sd">          library).</span>
<span class="sd">        latest (str): name of the latest, complete potential file that can be</span>
<span class="sd">          used to make predictions for configurations.</span>
<span class="sd">        configs (list): of `str` configuration ids from the database</span>
<span class="sd">          that should be included in the training and validation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gp_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">e0</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">default_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sparse_jitter</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">execution</span><span class="o">=</span><span class="p">{},</span> <span class="n">configs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">db</span>
        <span class="k">if</span> <span class="n">db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot train a GAP without a database of &quot;</span>
                             <span class="s2">&quot;configurations!&quot;</span><span class="p">)</span>

        <span class="n">ogap</span><span class="p">,</span> <span class="n">others</span> <span class="o">=</span> <span class="n">_extract_pots</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gap</span> <span class="o">=</span> <span class="n">ogap</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">gap</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">gap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ogap</span> <span class="o">=</span> <span class="n">ogap</span>
        
        <span class="c1">#Check that if they specified a list of potentials, that it is ordered</span>
        <span class="c1">#correctly and contains all the pieces.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap</span> <span class="o">==</span> <span class="n">ogap</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        
        <span class="c1">#There are certain required parameters that must have default values. We</span>
        <span class="c1">#set these as named keyword arguments in the constructor. All other</span>
        <span class="c1">#teach_sparse parameters are contained in kwargs and were separated from</span>
        <span class="c1">#the regular potential definitions by _extract_pots() above.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e0</span> <span class="o">=</span> <span class="n">e0</span>
        <span class="k">if</span> <span class="n">default_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_sigma</span> <span class="o">=</span> <span class="n">default_sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse_jitter</span> <span class="o">=</span> <span class="n">sparse_jitter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="n">split</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">teach_sparse</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">others</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execution</span> <span class="o">=</span> <span class="n">execution</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">configs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">configs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">configs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">configs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">configs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">configs</span><span class="p">]</span>
        
        <span class="c1">#Now, we can finally setup the GAP fitting parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">kgap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">:</span>
            <span class="n">cdict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kgap</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">kgap</span> <span class="o">==</span> <span class="s2">&quot;soap&quot;</span><span class="p">:</span>
                <span class="n">update_soap</span><span class="p">(</span><span class="n">cdict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">update_nbody</span><span class="p">(</span><span class="n">cdict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">[</span><span class="n">kgap</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdict</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">hessfit</span> <span class="o">=</span> <span class="s2">&quot;hessian_delta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">teach_sparse</span>
        <span class="k">if</span> <span class="n">gp_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp_file</span> <span class="o">=</span> <span class="n">gpfile_name</span><span class="p">(</span><span class="n">ogap</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">hessfit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hessfit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gp_file</span> <span class="o">=</span> <span class="n">gp_file</span>

        <span class="c1">#Configure the fitting directory for this particular set of</span>
        <span class="c1">#potentials. This way, we can get separate directories if the number of</span>
        <span class="c1">#n-body or soap potentials changes.</span>
        <span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">mkdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gp_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.xml&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">):</span>
            <span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>

        <span class="c1">#If we are doing hessian training, copy the seed configuration and</span>
        <span class="c1">#updates its hessian attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#Finally, determine where we are in the execution of the potential</span>
        <span class="c1">#fitting chain. `teach_sparse` only writes out a potential file when the</span>
        <span class="c1">#fitting is complete, before which it doesn&#39;t put out any files.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">_get_max_gap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessfit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest</span> <span class="o">=</span> <span class="n">gpfile_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">hessfit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hessfit</span><span class="p">)</span>

        <span class="c1">#We need to increment the state; the object assumes that state is what</span>
        <span class="c1">#we are *aiming for*, whereas now it only has what has finished</span>
        <span class="c1">#executing.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ogap</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">ogap</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_next</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calculator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;ase.Calculator: GAP potential for the latest fitted file in the</span>
<span class="sd">        sequence (i.e., based on :attr:`latest`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an instance of :class:`ase.Calculator` using the latest</span>
<span class="sd">        fitted GAP potential in this trainer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">quippy.potential</span> <span class="k">import</span> <span class="n">Potential</span>
            <span class="kn">from</span> <span class="nn">matdb.utility</span> <span class="k">import</span> <span class="n">chdir</span>
            <span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">getcwd</span>
            <span class="k">with</span> <span class="n">chdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calculator</span> <span class="o">=</span> <span class="n">Potential</span><span class="p">(</span><span class="s2">&quot;IP GAP&quot;</span><span class="p">,</span> <span class="n">param_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">latest</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculator</span>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the path the `delta` parameter file for each of the GAPs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;deltas.json&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">validation_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a :class:`quippy.AtomsList` of configurations that can be</span>
<span class="sd">        used for potential validation. The atoms list will depend on the type of</span>
<span class="sd">        fit (Hessian or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessfit</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_hessians</span><span class="p">()</span>
                
            <span class="c1">#Use only those configurations derived from the seed configurations</span>
            <span class="c1">#that were actually included.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">quippy</span><span class="o">.</span><span class="n">AtomsList</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">holdout_file</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">quippy</span><span class="o">.</span><span class="n">AtomsList</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Return the global validation list from the whole database.</span>
            <span class="k">return</span> <span class="n">quippy</span><span class="o">.</span><span class="n">AtomsList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">holdout_file</span><span class="p">)</span>
    
<div class="viewcode-block" id="GAPTrainer.validate"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.GAPTrainer.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validates the latest calculator in this training sequence against the</span>
<span class="sd">        `holdout.xyz` configurations in the controller database.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: with keys [&quot;e_dft&quot;, &quot;e_gap&quot;] where the values are</span>
<span class="sd">            DFT-calculated and GAP-calculated predictions for the energies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#We need to split to get validation data. If the split has already been</span>
        <span class="c1">#done as part of a different training run, then it won&#39;t be done a</span>
        <span class="c1">#second time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>
        <span class="n">al</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validation_list</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">al</span><span class="p">):</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculator</span><span class="o">.</span><span class="n">cutoff</span><span class="p">())</span>
            <span class="n">a</span><span class="o">.</span><span class="n">calc_connect</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
        <span class="n">e_dft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">al</span><span class="o">.</span><span class="n">dft_energy</span><span class="p">)</span>
        <span class="n">e_gap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">al</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
        <span class="n">f_dft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">al</span><span class="o">.</span><span class="n">dft_force</span><span class="p">)</span>
        <span class="n">f_gap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">al</span><span class="o">.</span><span class="n">force</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;e_dft&quot;</span><span class="p">:</span> <span class="n">e_dft</span><span class="p">,</span>
            <span class="s2">&quot;e_gap&quot;</span><span class="p">:</span> <span class="n">e_gap</span><span class="p">,</span>
            <span class="s2">&quot;f_dft&quot;</span><span class="p">:</span> <span class="n">f_dft</span><span class="p">,</span>
            <span class="s2">&quot;f_gap&quot;</span><span class="p">:</span> <span class="n">f_gap</span>
        <span class="p">}</span></div>
    
    <span class="k">def</span> <span class="nf">_get_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">igap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimates the value to use for the `delta` parameter for the next GAP</span>
<span class="sd">        in the list.</span>

<span class="sd">        Args:</span>
<span class="sd">            igap (int): *index* of the n-body code for the GAP (SOAP=10) in</span>
<span class="sd">              :attr:`latest`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: value for the `teach_sparse` delta parameter of the next GAP</span>
<span class="sd">            in the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#We cache the list of previous `delta` values for each GAP in a JSON</span>
        <span class="c1">#file so that we don&#39;t have to keep re-calculating them.</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_cache</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_cache</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">deltas</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deltas</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#See if we already have this delta in our list.</span>
        <span class="n">ngap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">igap</span><span class="p">]</span>
        <span class="n">dname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogap</span><span class="p">[</span><span class="n">ngap</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dname</span> <span class="ow">in</span> <span class="n">deltas</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deltas</span><span class="p">[</span><span class="n">dname</span><span class="p">]</span>
            
        <span class="c1">#:attr:`latest` has the name of the GAP file with the latest potential</span>
        <span class="c1">#in the sequence. Use it to get predictions and errors for a set of</span>
        <span class="c1">#configurations.</span>
        <span class="k">if</span> <span class="n">igap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>
            <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ens</span><span class="p">[</span><span class="s2">&quot;e_dft&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">ens</span><span class="p">[</span><span class="s2">&quot;e_gap&quot;</span><span class="p">])</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1:.3f}</span><span class="s2"> RMS error.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latest</span><span class="p">,</span> <span class="n">rms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">)</span>
            
            <span class="n">al</span> <span class="o">=</span> <span class="n">quippy</span><span class="o">.</span><span class="n">AtomsList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">train_file</span><span class="p">)</span>
            <span class="n">ens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">al</span><span class="p">:</span>
                <span class="n">ens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dft_energy</span><span class="p">)</span>
            <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ens</span><span class="p">)</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;2B: </span><span class="si">{0:.3f}</span><span class="s2"> data variance.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rms</span><span class="p">))</span>
        
        <span class="c1">#We use the first seed configuration in the database and calculate how</span>
        <span class="c1">#many nearest neighbors it has within the specified cutoff of the n-body</span>
        <span class="c1">#configuration. SOAP doesn&#39;t rescale because the descriptors are already</span>
        <span class="c1">#per-atom.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dbset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">dbset</span><span class="o">.</span><span class="n">atoms</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="s2">&quot;2body&quot;</span> <span class="o">==</span> <span class="n">dname</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span>  <span class="n">_rescale_2body</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">[</span><span class="s2">&quot;2body&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;3body&quot;</span> <span class="o">==</span> <span class="n">dname</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span>  <span class="n">_rescale_3body</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">[</span><span class="s2">&quot;3body&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;soap&quot;</span> <span class="o">==</span> <span class="n">dname</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="mf">1.</span>
            
        <span class="c1">#Now, we scale the expected error by the number of descriptors per atom</span>
        <span class="c1">#in this particular GAP. Remember, the last element in state is the</span>
        <span class="c1">#*next* one in the sequence. But we need to rescale the one *before*</span>
        <span class="c1">#that, i.e., -2.</span>
        <span class="n">deltas</span><span class="p">[</span><span class="n">dname</span><span class="p">]</span> <span class="o">=</span> <span class="n">rms</span><span class="o">/</span><span class="n">scaling</span>
            
        <span class="c1">#Now that we have updated the deltas for the latest GAP, re-serialize</span>
        <span class="c1">#the dict.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_cache</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">deltas</span><span class="p">[</span><span class="n">dname</span><span class="p">]</span>
            
    <span class="k">def</span> <span class="nf">_get_hessians</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts the hessian matrix and assigns its eigenvalues and</span>
<span class="sd">        eigenvectors to relevant properties on copies of the seed configuration</span>
<span class="sd">        atoms objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matdb.database.phonon</span> <span class="k">import</span> <span class="n">PhononBase</span>
        <span class="kn">from</span> <span class="nn">fnmatch</span> <span class="k">import</span> <span class="n">fnmatch</span>
        
        <span class="n">hname</span> <span class="o">=</span> <span class="s2">&quot;hessian</span><span class="si">{}</span><span class="s2">&quot;</span>        
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dbset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">configs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#Skip all those seed configurations that are not explicitly</span>
                <span class="c1">#included in the training spec.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">configs</span><span class="p">]):</span>
                    <span class="k">continue</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">dbset</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dmatrix</span> <span class="o">=</span> <span class="n">dbset</span><span class="o">.</span><span class="n">databases</span><span class="p">[</span><span class="n">PhononBase</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dmatrix</span>
            <span class="n">eigvecs</span><span class="p">,</span> <span class="n">eigvals</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">[</span><span class="s2">&quot;eigvecs&quot;</span><span class="p">],</span> <span class="n">dmatrix</span><span class="p">[</span><span class="s2">&quot;eigvals&quot;</span><span class="p">]</span>
            <span class="n">atc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            
            <span class="n">ni</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eigvals</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>
                    <span class="n">ni</span> <span class="o">=</span> <span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">hsingle</span> <span class="o">=</span> <span class="n">hname</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span>
                    <span class="n">atc</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="n">hsingle</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">atc</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">atc</span><span class="p">,</span> <span class="n">hsingle</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
                    <span class="n">atc</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">hsingle</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ni</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">atc</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="s2">&quot;n_hessian&quot;</span><span class="p">,</span> <span class="n">ni</span><span class="p">)</span>

            <span class="c1">#Also add the zero forces. TODO: get the actual forces from the</span>
            <span class="c1">#relaxed DFT calculation.</span>
            <span class="n">atc</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s2">&quot;force&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">_write_hessian_trainxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recalc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes the h_train.xyz file that is needed for the Hessian-based</span>
<span class="sd">        training program.</span>

<span class="sd">        Args:</span>
<span class="sd">            recalc (bool): when True, re-create the xyz file with the seed</span>
<span class="sd">              configurations and hessians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_hessians</span><span class="p">()</span>
        <span class="n">outpath</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">outpath</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">recalc</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="kn">import</span> <span class="nn">quippy.cinoutput</span> <span class="k">as</span> <span class="nn">qcio</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">qcio</span><span class="o">.</span><span class="n">CInOutputWriter</span><span class="p">(</span><span class="n">outpath</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">a</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                
    <span class="k">def</span> <span class="nf">_desc_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the descriptor string for this training object, if it</span>
<span class="sd">        exists.</span>

<span class="sd">        Args:</span>
<span class="sd">            ptype (str): one of [&quot;soap&quot;, &quot;2body&quot;, &quot;3body&quot;, &quot;4body&quot;].</span>
<span class="sd">            kwargs (dict): additional key-value pairs to include in the</span>
<span class="sd">              dictionary before compiling the string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ptype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">:</span>
            <span class="n">pdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">[</span><span class="n">ptype</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sparse_method&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
                <span class="n">pdict</span><span class="p">[</span><span class="s2">&quot;sparse_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;soap_sparse_points.dat&quot;</span>
            
            <span class="n">settings</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">settings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;soap&quot;</span> <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;soap&quot;</span> <span class="k">else</span> <span class="s2">&quot;distance_Nb&quot;</span><span class="p">)</span>
            <span class="n">settings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dict_to_str</span><span class="p">(</span><span class="n">pdict</span><span class="p">))</span>
            <span class="n">settings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;add_species&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
                
    <span class="k">def</span> <span class="nf">_soap_sparse_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recalc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the hessian sparse points for hessian-based</span>
<span class="sd">        training.</span>

<span class="sd">        Args:</span>
<span class="sd">            recalc (bool): when True, recalculate the sparse points even if the</span>
<span class="sd">              file already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spfile</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;soap_sparse_points.dat&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">spfile</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">recalc</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1">#Determine how many sparse points we need to generate.</span>
        <span class="n">n_sparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">[</span><span class="s2">&quot;soap&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_sparse&quot;</span><span class="p">)</span>
        <span class="n">n_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_sparse</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="p">)))</span>
        <span class="c1">#Reset n_sparse to be this whole number.</span>
        <span class="n">n_sparse</span> <span class="o">=</span> <span class="n">n_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="p">)</span>
        
        <span class="n">desc</span> <span class="o">=</span> <span class="n">quippy</span><span class="o">.</span><span class="n">Descriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc_str</span><span class="p">(</span><span class="s2">&quot;soap&quot;</span><span class="p">))</span>

        <span class="c1">#Run each of the seed configurations once until we hit the ratio</span>
        <span class="c1">#limit.</span>
        <span class="n">spoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">atc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">seed_pts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_ratio</span><span class="p">)</span><span class="o">/</span><span class="n">atc</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_seed</span><span class="p">):</span>
                <span class="n">atRand</span> <span class="o">=</span> <span class="n">atc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">quippy</span><span class="o">.</span><span class="n">randomise</span><span class="p">(</span><span class="n">atRand</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
                <span class="n">atRand</span><span class="o">.</span><span class="n">set_cutoff</span><span class="p">(</span><span class="n">desc</span><span class="o">.</span><span class="n">cutoff</span><span class="p">())</span>
                <span class="n">atRand</span><span class="o">.</span><span class="n">calc_connect</span><span class="p">()</span>

                <span class="n">n_descriptors</span><span class="p">,</span> <span class="n">n_cross</span> <span class="o">=</span> <span class="n">desc</span><span class="o">.</span><span class="n">descriptor_sizes</span><span class="p">(</span><span class="n">atRand</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">quippy</span><span class="o">.</span><span class="n">fzeros</span><span class="p">((</span><span class="n">desc</span><span class="o">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="n">n_descriptors</span><span class="p">))</span>
                <span class="n">desc</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">atRand</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                
                <span class="c1">#We need to add some ones to the SOAP descriptor; they represent</span>
                <span class="c1">#the relative weights of each of the sparse points. We weight</span>
                <span class="c1">#them all equally.</span>
                <span class="n">seed_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">atRand</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">d</span><span class="p">)))</span>
                
            <span class="n">spoints</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">seed_pts</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">n_ratio</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">spoints</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="o">==</span> <span class="n">n_sparse</span>
        <span class="n">allpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">spoints</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">spfile</span><span class="p">,</span> <span class="n">allpoints</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">train_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the name of the XYZ training file that will be passed to the</span>
<span class="sd">        teach_sparse command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;hessian_delta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">teach_sparse</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;h_train.xyz&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;train.xyz&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the name of the jobfile for the current training iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;jobfile.sh&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nmax</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;jobfile_soap.sh&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;jobfile_</span><span class="si">{}</span><span class="s2">.sh&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span>
        
<div class="viewcode-block" id="GAPTrainer.execute"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.GAPTrainer.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Submits the job script for the currently configured potential</span>
<span class="sd">        training.</span>

<span class="sd">        Args:</span>
<span class="sd">            dryrun (bool): when True, simulate the submission without</span>
<span class="sd">              actually submitting.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the submission generated a job id</span>
<span class="sd">            (considered successful).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jobfile</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1">#Make sure we have the `train.xyz` or `h_train.xyz` file; it is the only</span>
        <span class="c1">#dependency that we need for teach_sparse.</span>
        <span class="n">trainfile</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_file</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">trainfile</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">matdb.msg</span> <span class="k">import</span> <span class="n">std</span>
            <span class="n">std</span><span class="p">(</span><span class="s2">&quot;*train.xyz missing in </span><span class="si">{}</span><span class="s2">; can&#39;t execute.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1"># We must have what we need to execute. Compile the command</span>
        <span class="c1"># and submit.</span>
        <span class="kn">from</span> <span class="nn">matdb.utility</span> <span class="k">import</span> <span class="n">execute</span>
        <span class="n">cargs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sbatch&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jobfile</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dryrun</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">matdb.msg</span> <span class="k">import</span> <span class="n">okay</span>
            <span class="n">okay</span><span class="p">(</span><span class="s2">&quot;Executed </span><span class="si">{}</span><span class="s2"> in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cargs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xres</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">cargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xres</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s2">&quot;Submitted&quot;</span> <span class="ow">in</span> <span class="n">xres</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="kn">from</span> <span class="nn">matdb.msg</span> <span class="k">import</span> <span class="n">okay</span>
            <span class="n">okay</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">xres</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>
            
<div class="viewcode-block" id="GAPTrainer.write_jobfile"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.GAPTrainer.write_jobfile">[docs]</a>    <span class="k">def</span> <span class="nf">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets up the job file for the next GAP in the potential that needs to</span>
<span class="sd">        be executed. This includes creating folders, training XYZ files and</span>
<span class="sd">        setting up any other dependencies required by `teach_sparse`.</span>

<span class="sd">        .. note:: Calling the method assumes that you are using a newly</span>
<span class="sd">          constructed :class:`GAPTrainer`. The initialization of the class</span>
<span class="sd">          determines where in the fitting sequence of a `2 + 3 + ...` GAP</span>
<span class="sd">          potential we are. If you call this repeatedly with the same class in</span>
<span class="sd">          memory, it won&#39;t progress.</span>

<span class="sd">        .. note:: This method also runs :meth:`command`, which configures the</span>
<span class="sd">          directory that the executable will run in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jobfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">return</span>
        
        <span class="c1"># We use the global execution parameters and then any updates</span>
        <span class="c1"># locally. We need to add the execution directory (including prefix) and</span>
        <span class="c1"># the number of jobs in the array.</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execution</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;execution_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;exec_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">jinja2</span> <span class="k">import</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">PackageLoader</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span><span class="n">loader</span><span class="o">=</span><span class="n">PackageLoader</span><span class="p">(</span><span class="s1">&#39;matdb&#39;</span><span class="p">,</span> <span class="s1">&#39;templates&#39;</span><span class="p">))</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;template&quot;</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">))</span></div>

<div class="viewcode-block" id="GAPTrainer.command"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.GAPTrainer.command">[docs]</a>    <span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the `teach_sparse` command that is needed to train the GAP</span>
<span class="sd">        potentials specified by this object.</span>

<span class="sd">        .. note:: This method also configures the directory that the command</span>
<span class="sd">          will run in so that it has the relevant files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#First, tell the DB to split over training and holdout.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessfit</span><span class="p">:</span>
            <span class="c1">#Generate the sparse points file and the seed configuration XYZ</span>
            <span class="c1">#training file.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_hessian_trainxyz</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;soap&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">[</span><span class="s2">&quot;soap&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sparse_method&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_soap_sparse_points</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#The split command writes the XYZ files using a new random subset of</span>
            <span class="c1">#the available configurations.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">)</span>
        
        <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;teach_sparse at_file=</span><span class="si">{train_file}</span><span class="s2"> gap={{</span><span class="si">{gap}</span><span class="s2">}} </span><span class="si">{teach_sparse}</span><span class="s2">&quot;</span>
        <span class="c1">#Compile the GAP string specifying the potential.</span>
        <span class="n">gaplist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">igap</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">):</span>
            <span class="n">kgap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogap</span><span class="p">[</span><span class="n">igap</span><span class="p">]</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_delta</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">igap</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">gaplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc_str</span><span class="p">(</span><span class="n">kgap</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">igap</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gaplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc_str</span><span class="p">(</span><span class="n">kgap</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">))</span>
            
        <span class="n">gapstr</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gaplist</span><span class="p">)</span>

        <span class="n">tsattrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;e0&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">e0</span><span class="p">,</span>
            <span class="s2">&quot;default_sigma&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_sigma</span><span class="p">,</span>
            <span class="s2">&quot;sparse_jitter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_jitter</span><span class="p">,</span>
            <span class="s2">&quot;gp_file&quot;</span><span class="p">:</span> <span class="n">gpfile_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">hessfit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hessfit</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">tsattrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">teach_sparse</span><span class="p">)</span>
        <span class="n">tsstr</span> <span class="o">=</span> <span class="n">dict_to_str</span><span class="p">(</span><span class="n">tsattrs</span><span class="p">)</span>
                
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;train_file&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_file</span><span class="p">,</span>
            <span class="s2">&quot;gap&quot;</span><span class="p">:</span> <span class="n">gapstr</span><span class="p">,</span>
            <span class="s2">&quot;teach_sparse&quot;</span><span class="p">:</span> <span class="n">tsstr</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span></div>

<div class="viewcode-block" id="GAPTrainer.status"><a class="viewcode-back" href="../../../fitting/gap.html#matdb.fitting.gap.GAPTrainer.status">[docs]</a>    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns or prints the current status of the GAP training.</span>

<span class="sd">        Args:</span>
<span class="sd">            printed (bool): when True, print the status to screen; otherwise,</span>
<span class="sd">              return a dictionary with the relevant quantities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Our interest is in knowing which GAP model is the latest (if any) and</span>
        <span class="c1"># whether the job script has been created for the next one in the</span>
        <span class="c1"># sequence.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;latest&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">latest</span><span class="p">,</span>
            <span class="s2">&quot;jobfile&quot;</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jobfile</span><span class="p">))</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">printed</span><span class="p">:</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Latest GAP model: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;latest&quot;</span><span class="p">]))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;exists&quot;</span> <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;jobfile&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;does not exist&quot;</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Next jobfile &#39;</span><span class="si">{}</span><span class="s2">&#39; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jobfile</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">matdb 0.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Conrad W. Rosenbrock.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>