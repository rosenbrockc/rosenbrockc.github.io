

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>gblearn.decomposition &#8212; gblearn 0.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">gblearn 0.2.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gblearn.decomposition</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Methods for decomposing the SOAP vectors into radial and angular</span>
<span class="sd">components for analysis.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">gblearn</span> <span class="k">import</span> <span class="n">msg</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">5e-5</span>
<span class="sd">&quot;&quot;&quot;float: finite precision comparison value for RDF norms.</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="pissnnl"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.pissnnl">[docs]</a><span class="k">def</span> <span class="nf">pissnnl</span><span class="p">(</span><span class="n">pissnnl</span><span class="p">,</span> <span class="n">nspecies</span><span class="p">,</span> <span class="n">vcutoff</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the geometric information for any entries of a pissnnl</span>
<span class="sd">    vector higher than the specified cutoff. </span>

<span class="sd">    Args:</span>
<span class="sd">        pissnnl (numpy.ndarray): vector to examine.</span>
<span class="sd">        nspecies (int): number of species for the SOAP descriptor.</span>
<span class="sd">        vcutoff (float): values higher than this will be returned with</span>
<span class="sd">          geometry information.</span>
<span class="sd">        nmax (int): bandwidth limits for the SOAP descriptor radial basis</span>
<span class="sd">          functions.</span>
<span class="sd">        lmax (int): bandwidth limits for the SOAP descriptor spherical harmonics.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: of tuples with (index, value, (n_i, s_i), (n_j, s_j), l), where `n_i`</span>
<span class="sd">          is the `n` value of the radial basis function for species `i`, and `s_i`</span>
<span class="sd">          is the value of the species index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rs_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">nspecies</span><span class="o">*</span><span class="n">nmax</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nspecies</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">rs_index</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="n">ipow</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nspecies</span><span class="o">*</span><span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ia</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ipow</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pissnnl</span><span class="p">):</span><span class="c1"># pragma: no cover</span>
                    <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">ipow</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pissnnl</span><span class="p">[</span><span class="n">ipow</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">vcutoff</span><span class="p">:</span>
                    <span class="n">ra</span> <span class="o">=</span> <span class="n">rs_index</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">ia</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">sa</span> <span class="o">=</span> <span class="n">rs_index</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">ia</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">rb</span> <span class="o">=</span> <span class="n">rs_index</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">jb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">sb</span> <span class="o">=</span> <span class="n">rs_index</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">jb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ipow</span><span class="p">,</span> <span class="n">pissnnl</span><span class="p">[</span><span class="n">ipow</span><span class="p">],</span> <span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">sa</span><span class="p">),</span> <span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="n">sb</span><span class="p">),</span> <span class="n">l</span><span class="p">))</span>
                <span class="n">ipow</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;skipped </span><span class="si">{}</span><span class="s2"> entries in the vector.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">skip</span><span class="p">))</span>

    <span class="n">dmsg</span> <span class="o">=</span> <span class="s2">&quot;Considered </span><span class="si">{}</span><span class="s2"> entries in P vector (size=</span><span class="si">{}</span><span class="s2">).&quot;</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">dmsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ipow</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pissnnl</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="fcut"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.fcut">[docs]</a><span class="k">def</span> <span class="nf">fcut</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rcut</span><span class="p">,</span> <span class="n">trans_width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies the cutoff function to the coefficients so that the</span>
<span class="sd">    function will go smoothly to zero at the cutoff.</span>

<span class="sd">    Args:</span>
<span class="sd">        r (float): radial distance parameter.</span>
<span class="sd">        rcut (float): values greater than this are identically zero.</span>
<span class="sd">        trans_width(float): the transition to zero at the cutoff happens</span>
<span class="sd">          smoothly across this width.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: value in [0., 1.] to multiply the coefficient by so</span>
<span class="sd">          that all values fall within the specified cutoff.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fcut</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">rcut</span><span class="p">,</span> <span class="n">trans_width</span><span class="p">)</span> <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">r</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">rcut</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">rcut</span><span class="o">-</span><span class="n">trans_width</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">rcut</span><span class="o">+</span><span class="n">trans_width</span><span class="p">)</span><span class="o">/</span><span class="n">trans_width</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span></div>
        
<div class="viewcode-block" id="SOAPDecomposer"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer">[docs]</a><span class="k">class</span> <span class="nc">SOAPDecomposer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements decompsition of vectors in the SOAP space allowing</span>
<span class="sd">    for differing `lmax` and `nmax` values in a single session. Uses</span>
<span class="sd">    caching to optimize the decomposition.</span>

<span class="sd">    Args:</span>
<span class="sd">        nspecies (int): number of species for the SOAP descriptor.</span>
<span class="sd">        nmax (int): bandwidth limits for the SOAP descriptor radial basis</span>
<span class="sd">          functions.</span>
<span class="sd">        lmax (int): bandwidth limits for the SOAP descriptor spherical</span>
<span class="sd">          harmonics.</span>
<span class="sd">        rcut (float): local environment finite cutoff parameter.</span>
<span class="sd">        sigma (float): width parameter for the Gaussians on each atom.</span>
<span class="sd">        trans_width (float): distance over which the coefficients in the</span>
<span class="sd">            radial functions are smoothly transitioned to zero.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        alpha (float): constant affecting the width of the Gaussians. Inversely</span>
<span class="sd">          proportional to :attr:`sigma`.</span>
<span class="sd">        rb (numpy.ndarray): positions of radial basis functions in the</span>
<span class="sd">          radial space.</span>
<span class="sd">        partitions (dict): keys are `tuple` of (`l` values, inverse); values are the</span>
<span class="sd">          corresponding indices that form the partition.</span>
<span class="sd">        fcrs (dict): keys are `float` values for radius `r`; values are :func:`fcut`</span>
<span class="sd">          evaluated at `r`.</span>
<span class="sd">        rbexp (list): of `float` values; the `n`-dependent exponential</span>
<span class="sd">          damping factor for radial basis function values.</span>
<span class="sd">        rbsph (dict): keys are `tuple` (n,l,r) where `n` and `l` are the integer</span>
<span class="sd">          radial and spherical basis function indices and `r` is the `float` value</span>
<span class="sd">          at which the spherical bessel function was evaluated.</span>
<span class="sd">        cRs (dict): keys are `float` values of radius `r`; values are the</span>
<span class="sd">          corresponding coefficient matrices returned by</span>
<span class="sd">          :meth:`_c_numeric`.</span>
<span class="sd">        aRs (dict): keys are `tuple` (n,l,r) where `n` and `l` are the integer</span>
<span class="sd">          radial and spherical basis function indices and `r` is the `float`</span>
<span class="sd">          value that the radial functions were evaluated at; values are the</span>
<span class="sd">          corresponding coefficients of the radial basis functions.</span>
<span class="sd">        transformbasis (numpy.ndarray): transformation matrix needed to account for</span>
<span class="sd">          radial basis function positions when calculating the radial function</span>
<span class="sd">          coefficients using linear algebra.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nspecies</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">rcut</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">trans_width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspecies</span> <span class="o">=</span> <span class="n">nspecies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">=</span> <span class="n">lmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span> <span class="o">=</span> <span class="n">nmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="o">=</span> <span class="n">rcut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_width</span> <span class="o">=</span> <span class="n">trans_width</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radial_basis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1">#All of these next dictionaries are used only when caching is enabled to</span>
        <span class="c1">#speed up the calculation. It speeds things up by about 4 or 5 times.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fcrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rbexp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rbsph</span> <span class="o">=</span> <span class="p">{}</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">cRs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aRs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformbasis</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SOAPDecomposer.get_params"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionary of the constructor parameters needed to</span>
<span class="sd">        re-initialize this decomposer instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;nspecies&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspecies</span><span class="p">,</span>
            <span class="s2">&quot;lmax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span>
            <span class="s2">&quot;nmax&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">,</span>
            <span class="s2">&quot;rcut&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span><span class="p">,</span>
            <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span>
            <span class="s2">&quot;trans_width&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_width</span>
            <span class="p">}</span></div>
        
    <span class="k">def</span> <span class="nf">_init_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the linear algebra matrices for the radial basis so that</span>
<span class="sd">        the coefficients can be solved using :meth:`cnl`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erf</span>
        <span class="n">covbasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">))</span>
        <span class="n">overbasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">))</span>
        <span class="c1">#Get local references to these variables so that we don&#39;t need `self`</span>
        <span class="c1">#all over in the overbasis calculation below.</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">rb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rb</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">):</span>
                <span class="n">covbasis</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">rb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">rb</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">overbasis</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">rb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rb</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span> 
                                  <span class="n">alpha</span><span class="o">**</span><span class="mf">1.5</span><span class="o">*</span><span class="p">(</span><span class="n">rb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">rb</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> 
                                  <span class="n">alpha</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">rb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">rb</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span>
                                  <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">rb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">rb</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span>
                                  <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">erf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">rb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">rb</span><span class="p">[</span><span class="n">j</span><span class="p">]))))</span>
                
        <span class="n">overbasis</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">128.</span> <span class="o">*</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">cholesky</span>
        <span class="n">choloverlap</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">overbasis</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">choloverlap</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">solve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformbasis</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">covbasis</span><span class="p">,</span> <span class="n">choloverlap</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_radial_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the radial basis using the initialization</span>
<span class="sd">        parameters passed to the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errexp</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">cutbasis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">errexp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">))</span>
        <span class="n">spacebasis</span> <span class="o">=</span> <span class="n">cutbasis</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span>
        <span class="n">rbasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">)</span>
        <span class="n">rbasis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">):</span>
            <span class="n">rbasis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rbasis</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">spacebasis</span>
        <span class="k">return</span> <span class="n">rbasis</span>

    <span class="k">def</span> <span class="nf">_c_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rij</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the matrix of radial basis function coefficients for all</span>
<span class="sd">        `l` and `n` indices up to `self.nmax` and `self.lmax` at once using</span>
<span class="sd">        linear algebra for the specified radial distance `r`.</span>

<span class="sd">        Args:</span>
<span class="sd">            rij (float): distance between atoms `i` and `j` in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">radial_fun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">))</span>
        <span class="n">radial_fun</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1">#Get local references to these variables so that we don&#39;t need `self`</span>
        <span class="c1">#all over in the overbasis calculation below.</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">rb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rb</span>        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">argbess</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">rij</span>
            <span class="n">ep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">rij</span> <span class="o">+</span> <span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">em</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">rij</span> <span class="o">-</span> <span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1">#In the loops below, msb prefix refers to modified spherical bessel.</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">argbess</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">msb_fi_ki_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">rij</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#msb_fi_ki_lm = cosh(arg_bess)/arg_bess</span>
                        <span class="c1">#msb_fi_ki_l = sinh(arg_bess)/arg_bess</span>
                        <span class="n">msb_fi_ki_lm</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">em</span> <span class="o">+</span> <span class="n">ep</span><span class="p">)</span> <span class="o">/</span> <span class="n">argbess</span>
                        <span class="n">msb_fi_ki_l</span>  <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">em</span> <span class="o">-</span> <span class="n">ep</span><span class="p">)</span> <span class="o">/</span> <span class="n">argbess</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">argbess</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">msb_fi_ki_l</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">msb_fi_ki_lmm</span> <span class="o">=</span> <span class="n">msb_fi_ki_lm</span>
                        <span class="n">msb_fi_ki_lm</span> <span class="o">=</span> <span class="n">msb_fi_ki_l</span>
                        <span class="n">msb_fi_ki_l</span> <span class="o">=</span> <span class="n">msb_fi_ki_lmm</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">msb_fi_ki_lm</span><span class="o">/</span><span class="n">argbess</span>

                <span class="n">radial_fun</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msb_fi_ki_l</span> <span class="c1">#* rb[n-1]</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fcut</span><span class="p">(</span><span class="n">rij</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_width</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">radial_fun</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformbasis</span><span class="p">)</span><span class="o">*</span><span class="n">fc</span>
    
<div class="viewcode-block" id="SOAPDecomposer.cnl"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer.cnl">[docs]</a>    <span class="k">def</span> <span class="nf">cnl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cnum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the coefficient of the radial basis function</span>
<span class="sd">        :math:`g_n(r)`.</span>

<span class="sd">        Args:</span>
<span class="sd">            n (int): index of the radial basis function.</span>
<span class="sd">            l (int): index of the spherical harmonic associated with the</span>
<span class="sd">              radial function.</span>
<span class="sd">            r (float): value at which to evaluate the basis function</span>
<span class="sd">              :math:`g_n(r)`.</span>
<span class="sd">            cnum (bool): when True, the function is evaluated numerically</span>
<span class="sd">              using linear algebra instead of the built-in `numpy`</span>
<span class="sd">              functions; can be faster, but the results can have numerical</span>
<span class="sd">              noise issues.</span>
<span class="sd">            fast (bool): when True, caching is used to speed up evaluation</span>
<span class="sd">              of the basis functions between multiple `pissnnl` vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cnum</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformbasis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_numeric</span><span class="p">()</span>
                
            <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cRs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cRs</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_numeric</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cRs</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">sph_in</span>
            <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fcrs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fcrs</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">fcut</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcut</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_width</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbsph</span><span class="p">:</span>
                    <span class="n">besseli</span> <span class="o">=</span> <span class="n">sph_in</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rbsph</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span> <span class="o">=</span> <span class="n">besseli</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aRs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">aRs</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fcrs</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">*</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">rbexp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">rbsph</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)])</span>
            
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aRs</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#pragma: no cover</span>
                <span class="c1">#There is no real sense in not using the cached method since the</span>
                <span class="c1">#results are identical. However, we keep it here for reference.</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">fcut</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span>
                        <span class="n">sph_in</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="SOAPDecomposer.apnl"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer.apnl">[docs]</a>    <span class="k">def</span> <span class="nf">apnl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">cnum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the analytically/numerically derived coefficient for the</span>
<span class="sd">        specified, decomposed pissnnl.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            dp (tuple): (`int` index in `P`, `float` cnlm, </span>
<span class="sd">              (`int` ni, `int` si), (`int` nj, `int` sj), `int` l). These tuples</span>
<span class="sd">              are calculated in bulk for a `pissnnl` vector using</span>
<span class="sd">              :func:`gblearn.decomposition.pissnnl`.</span>
<span class="sd">            rx (numpy.ndarray): linear space of values to evaluate at.</span>
<span class="sd">            cnum (bool): when True, the function is evaluated numerically</span>
<span class="sd">              using linear algebra instead of the built-in `numpy`</span>
<span class="sd">              functions. See also :meth:`cnl`.</span>
<span class="sd">            fast (bool): when True, caching is used to speed up evaluation</span>
<span class="sd">              of the basis functions between multiple `pissnnl` vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ni</span><span class="p">,</span> <span class="n">si</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nj</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">cnl</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">fast</span><span class="p">)</span> <span class="o">*</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">cnl</span><span class="p">(</span><span class="n">nj</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">fast</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rx</span><span class="p">])</span></div>

<div class="viewcode-block" id="SOAPDecomposer.RDF"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer.RDF">[docs]</a>    <span class="k">def</span> <span class="nf">RDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dP</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the summed radial distribution function for the specified</span>
<span class="sd">        decomposed `P` vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            dp (tuple): (`int` index in `P`, `float` cnlm, </span>
<span class="sd">              (`int` ni, `int` si), (`int` nj, `int` sj), `int` l). These tuples</span>
<span class="sd">              are calculated in bulk for a `P` vector using</span>
<span class="sd">              :func:`gblearn.decomposition.pissnnl`.</span>
<span class="sd">            rx (numpy.ndarray): linear space of values to evaluate at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dP</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">rx</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dPi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dP</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dPi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dPi</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">apnl</span><span class="p">(</span><span class="n">dPi</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_renorm_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the re-normalized coefficient of expansion for use in</span>
<span class="sd">        rebuilding the radial and angular distribution functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
    
    <span class="k">def</span> <span class="nf">_ang_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angular grouping by `l` for the specified P decomposition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="n">dsP</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dP</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;Pij&quot;</span><span class="p">,</span> <span class="s2">&quot;nisi&quot;</span><span class="p">,</span> <span class="s2">&quot;njsj&quot;</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">])</span>
        <span class="n">dsP</span><span class="p">[</span><span class="s2">&quot;Pij&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsP</span><span class="p">[</span><span class="s2">&quot;Pij&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_renorm_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dsP</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()[</span><span class="s2">&quot;Pij&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

<div class="viewcode-block" id="SOAPDecomposer.ADF"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer.ADF">[docs]</a>    <span class="k">def</span> <span class="nf">ADF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dP</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the angular distribution function for the given SOAP</span>
<span class="sd">        vector decomposition.</span>

<span class="sd">        Args:</span>
<span class="sd">            dp (tuple): (`int` index in `P`, `float` cnlm, </span>
<span class="sd">              (`int` ni, `int` si), (`int` nj, `int` sj), `int` l). These tuples</span>
<span class="sd">              are calculated in bulk for a `P` vector using</span>
<span class="sd">              :func:`gblearn.decomposition.pissnnl`.</span>
<span class="sd">            ax (numpy.ndarray): linear space of polar angle values to evaluate</span>
<span class="sd">              at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">sph_harm</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ang_part</span><span class="p">(</span><span class="n">dP</span><span class="p">)</span>
        <span class="c1">#scipy defines their harmonics to have `theta` be azimuthal, which is</span>
        <span class="c1">#opposite from physics.</span>
        <span class="c1">#we set $m = 0$ so that the azimuthal part doesn&#39;t contribute at all.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ang</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Ylm</span> <span class="o">=</span> <span class="n">sph_harm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#We are interested in the c* c of this value, which is multiplied</span>
            <span class="c1">#together to get pissnnl.</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">p</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">Ylm</span><span class="o">*</span><span class="n">Ylm</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="SOAPDecomposer.decompose"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer.decompose">[docs]</a>    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">vcutoff</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decomposes the specified SOAP vector into its radial and angular</span>
<span class="sd">        contributions using :func:`gblearn.decomposition.pissnnl`.</span>

<span class="sd">        Args:</span>
<span class="sd">            P (numpy.ndarray): vector representing the projection of a local</span>
<span class="sd">              atomic environment into the SOAP space.</span>
<span class="sd">            vcutoff (float): values higher than this will be included in the</span>
<span class="sd">              RDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pissnnl</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspecies</span><span class="p">,</span> <span class="n">vcutoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOAPDecomposer.partition"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPDecomposer.partition">[docs]</a>    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lfilter</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of indices for a `P` vector that correspond to the</span>
<span class="sd">        specified `l` values.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            lfilter (list): of `l` values to include in the resulting indices.</span>
<span class="sd">            inverse (bool): when True, then any `l` values *not* in `lfilter` are</span>
<span class="sd">              included instead of the inverse.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray): of `int` indices that have the specified `l` values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lfilter</span><span class="p">),</span> <span class="n">inverse</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">:</span>
            <span class="n">rs_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspecies</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspecies</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">rs_index</span><span class="p">[:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    
            <span class="n">ipow</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspecies</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ia</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">inverse</span> <span class="ow">and</span> <span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lfilter</span><span class="p">)</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="ow">not</span> <span class="n">inverse</span> <span class="ow">and</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lfilter</span><span class="p">)):</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipow</span><span class="p">)</span>
                        <span class="n">ipow</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div></div>

<span class="k">def</span> <span class="nf">_plot_shells</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">shells</span><span class="p">,</span> <span class="n">maxy</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds the specified shells to axes using a linear colorspace.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax (matplotlib.axes.Axes): axes to plot on. If not specified, a new</span>
<span class="sd">          figure and new axes will be created.</span>
<span class="sd">        shells (list): of `float` values for neighbor shells to be added as</span>
<span class="sd">          vertical lines to the plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">shells</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">gblearn.utility</span> <span class="k">import</span> <span class="n">colorspace</span>
        <span class="n">cycols</span> <span class="o">=</span> <span class="n">colorspace</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">shell</span> <span class="ow">in</span> <span class="n">shells</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">shell</span><span class="p">,</span><span class="n">shell</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">maxy</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="nb">next</span><span class="p">(</span><span class="n">cycols</span><span class="p">),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="DF"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DF">[docs]</a><span class="k">class</span> <span class="nc">DF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the Radial or Angluar Distribution Function of a SOAP vector.</span>

<span class="sd">    Args:</span>
<span class="sd">        dP (list): of tuples; result of calling</span>
<span class="sd">          :func:`gblearn.decomposition.pissnnl` on the SOAP vector with</span>
<span class="sd">          :math:`l=0` or :math:`l&gt;0` components set to zero.</span>
<span class="sd">        catom (bool): when True, this DF is for the *central* atom only (i.e.,</span>
<span class="sd">          :math:`l=0` components only).</span>
<span class="sd">        x (numpy.ndarray): domain in radial/angular space on which to sample</span>
<span class="sd">          the function.    </span>
<span class="sd">        decomposer (SOAPDecomposer): instance used to decompose the SOAP vector; has</span>
<span class="sd">          configuration information for SOAP parameters and caches for rapid</span>
<span class="sd">          evaluation of the basis functions.</span>
<span class="sd">        calculate (bool): when True, the distribution function will be calculated</span>
<span class="sd">          upon initialization.</span>
<span class="sd">    Attributes:</span>
<span class="sd">        df (numpy.ndarray): distribution function values corresponding to</span>
<span class="sd">          :attr:`x`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dP</span><span class="p">,</span> <span class="n">catom</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span> <span class="n">radial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calculate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dP</span> <span class="o">=</span> <span class="n">dP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catom</span> <span class="o">=</span> <span class="n">catom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span> <span class="o">=</span> <span class="n">decomposer</span>
        <span class="c1">#We don&#39;t necessarily always want to re-calculate on construction. In</span>
        <span class="c1">#that case, the instance is just a useful container for its basic</span>
        <span class="c1">#parameters.</span>
        <span class="k">if</span> <span class="n">calculate</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">radial</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">decomposer</span><span class="o">.</span><span class="n">RDF</span><span class="p">(</span><span class="n">dP</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">decomposer</span><span class="o">.</span><span class="n">ADF</span><span class="p">(</span><span class="n">dP</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: :func:`numpy.linalg.norm` of the DF vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;R&quot;</span> <span class="k">if</span> <span class="n">radial</span> <span class="k">else</span> <span class="s2">&quot;A&quot;</span>
        <span class="sd">&quot;&quot;&quot;str: since this could be a radial *or* and angular DF, the type of</span>
<span class="sd">        the distribution function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DF</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the L2 norm of the distribution function values as if they</span>
<span class="sd">        were a vector in some space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span> <span class="k">as</span> <span class="n">lnorm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="n">lnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span>
        
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines the distance between two DFs using the dot product</span>
<span class="sd">        metric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only calculate distance between two DFs. of &quot;</span>
                            <span class="s2">&quot;the same type.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">norm</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>

<div class="viewcode-block" id="DF.from_file"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DF.from_file">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">decomposer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a DF from file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): path to the file that was created by</span>
<span class="sd">              :meth:`DF.save`.</span>
<span class="sd">            decomposer (SOAPDecomposer): instance used to decompose the SOAP vector; has</span>
<span class="sd">              configuration information for SOAP parameters and caches for rapid</span>
<span class="sd">              evaluation of the basis functions.</span>
<span class="sd">            x (numpy.ndarray): common domain values shared by a collection; used if</span>
<span class="sd">              the file doesn&#39;t explicitly specify the domain values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">load</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DF</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="DF.from_dict"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DF.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">decomposer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a DF from a serialized dict (i.e., one returned by</span>
<span class="sd">        :meth:`serialize`).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (dict): result of calling :meth:`serialize`.</span>
<span class="sd">            decomposer (SOAPDecomposer): instance used to decompose the SOAP vector; has</span>
<span class="sd">              configuration information for SOAP parameters and caches for rapid</span>
<span class="sd">              evaluation of the basis functions.</span>
<span class="sd">            x (numpy.ndarray): if this DF is constructed from a parent collection,</span>
<span class="sd">              the common domain sample vector to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DF</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dP&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;catom&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">decomposer</span><span class="p">,</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">calculate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;df&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="DF.serialize"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DF.serialize">[docs]</a>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">withdecomp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">commonx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">withdP</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a serializable dictionary that represents this DF.</span>

<span class="sd">        Args:</span>
<span class="sd">            withdecomp (bool): when True, include the parameters of the SOAP</span>
<span class="sd">              decomposer in the dict.</span>
<span class="sd">            commonx (numpy.ndarray): xf this DF is part of a collection, the domain</span>
<span class="sd">              values will be the same for every DF; in that case we don&#39;t need to</span>
<span class="sd">              include the domain in the serialization. This is the parent</span>
<span class="sd">              collections common radial vector. If the DFs is the same, it won&#39;t</span>
<span class="sd">              be serialized. If unspecified, the domain values are serialized.</span>
<span class="sd">            withdP (bool): when True, the large, decomposed SOAP vector values are</span>
<span class="sd">              serialized. Necessary to completely reconstruct the representation,</span>
<span class="sd">              but not necessary for most analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;dP&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dP</span> <span class="k">if</span> <span class="n">withdP</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;catom&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">catom</span><span class="p">,</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">commonx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                  <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">commonx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
            <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="s2">&quot;df&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">withdecomp</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="DF.save"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DF.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the DF to disk.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (str): path to save the vector to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">dump</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DF.same"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DF.same">[docs]</a>    <span class="k">def</span> <span class="nf">same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">epsilon_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests whether the specifed DF is similar to this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DF): DF to compare similarity to.</span>
<span class="sd">            epsilon_ (float): override the global (default) value</span>
<span class="sd">              :data:`~gblearn.decomposition.epsilon` for determining if the DFs</span>
<span class="sd">              are similar.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True when both of the DFs are identical within tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">epsilon_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">-</span><span class="n">other</span> <span class="o">&lt;</span> <span class="n">epsilon</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">-</span><span class="n">other</span> <span class="o">&lt;</span> <span class="n">epsilon_</span></div>
    
<div class="viewcode-block" id="DF.plot"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DF.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
             <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the DF.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax (matplotlib.axes.Axes): axes to plot on. If not specified, a new</span>
<span class="sd">              figure and new axes will be created. If axes are specifed, *no* `x`</span>
<span class="sd">              or `y` labels or plot titles will be added.</span>
<span class="sd">            savefile (str): path to a file if the figure should be saved.</span>
<span class="sd">            shells (list): of `float` values for neighbor shells to be added as</span>
<span class="sd">              vertical lines to the plot.</span>
<span class="sd">            opacity (float): transparency to use for the DF plot.</span>
<span class="sd">            color: any color option received by :func:`matplotlib.pyplot.plot`.</span>
<span class="sd">            title (str): override the default title of the plot.</span>
<span class="sd">            xlabel (str): override the default (generic, not very helpful) label for</span>
<span class="sd">              the x-axis.</span>
<span class="sd">            ylabel (str): override the default label for the y-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">axset</span> <span class="o">=</span> <span class="n">plt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axset</span> <span class="o">=</span> <span class="n">ax</span>

        <span class="n">axset</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Distribution Function of SOAP Vector&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xlabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Distance (unknown units)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Accumulated Density&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>

        <span class="n">_plot_shells</span><span class="p">(</span><span class="n">axset</span><span class="p">,</span> <span class="n">shells</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">savefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">savefile</span><span class="p">)</span>
            
        <span class="kn">from</span> <span class="nn">gblearn.base</span> <span class="k">import</span> <span class="n">testmode</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">testmode</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">axset</span></div></div>

<div class="viewcode-block" id="DFCollection"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection">[docs]</a><span class="k">class</span> <span class="nc">DFCollection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a collection of Distrubition Functions. A DF can only</span>
<span class="sd">    be added once to a collection (object instance comparison). Two identical</span>
<span class="sd">    DFs (in the physical sense) can belong to the same collection.</span>

<span class="sd">    Args:</span>
<span class="sd">        dfs (list): of :class:`DF` to intialize the collection with.</span>
<span class="sd">        counts (list): of `int` specifying how many DFs of each type are in the</span>
<span class="sd">          collection. For example, `self.counts[3]` says that we have three DFs</span>
<span class="sd">          in the collection that are identical to the DF in `self.dfs[3]`,</span>
<span class="sd">          though we only keep one of them.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        dfs (list): of :class:`DF` to intialize the collection with.</span>
<span class="sd">        counts (list): of `int` specifying how many DFs of each type are in the</span>
<span class="sd">          collection. For example, `self.counts[3]` says that we have three DFs</span>
<span class="sd">          in the collection that are identical to the DF in `self.dfs[3]`,</span>
<span class="sd">          though we only keep one of them.</span>
<span class="sd">        label (str): user-defined label for the collection.</span>
<span class="sd">        tags (dict): user-defined tags to identify this collection in a larger</span>
<span class="sd">          analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dfs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span> <span class="o">=</span> <span class="n">dfs</span>

        <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">))]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;bool: when True, this collection has already been tested for</span>
<span class="sd">        uniqueness. Any subsequent additions will be tested for uniqueness</span>
<span class="sd">        before adding them in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;int: number of DFs in the original list (before non-unique ones were</span>
<span class="sd">        removed). Useful for statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_average</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: averaged distribution function for the entire</span>
<span class="sd">        collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests the equality of this DFCollection with another.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DFCollection</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">sdf</span> <span class="o">==</span> <span class="n">odf</span> <span class="k">for</span> <span class="n">sdf</span><span class="p">,</span> <span class="n">odf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>    
        
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">DFCollection </span><span class="si">{1}</span><span class="s2"> with </span><span class="si">{2:d}</span><span class="s2"> items&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="c1">#This is just a sanity check. It should never happen unless someone</span>
            <span class="c1">#is hacking around in the code.</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="n">title</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate two collections together. This doesn&#39;t enforce any</span>
<span class="sd">        uniqueness constraints. Tags and labels are *not* updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only DFs of the same type can be combined.&quot;</span><span class="p">)</span>

        <span class="n">dfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">dfs</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">counts</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extend this collection with the other one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only DFs of the same type can be combined.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dfs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_original</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s2">&quot;+&quot;</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_average</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>
    
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">df</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;Only DFs of type </span><span class="si">{}</span><span class="s2"> can be placed in this collection.&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_average</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="DFCollection.dfs_from_soap"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.dfs_from_soap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dfs_from_soap</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a DF collection from the specified SOAPVector collection</span>
<span class="sd">        using the :math:`l&gt;0` components.</span>

<span class="sd">        Args:</span>
<span class="sd">            collection (SOAPVectorCollection): collection of SOAP vectors to</span>
<span class="sd">              initialize from.</span>
<span class="sd">            ctype (str): one of [&#39;RDF&#39;, &#39;ADF&#39;], specifies the kind of collection</span>
<span class="sd">              to initialize.</span>
<span class="sd">            resolution (int): number of points to sample in the radial domain.</span>
<span class="sd">            catom (bool): when True, the DFs are constructed using the density of</span>
<span class="sd">              the central atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;RDF&quot;</span><span class="p">,</span> <span class="s2">&quot;ADF&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;ctype&#39; must be either &#39;RDF&#39; or &#39;ADF&#39;.&quot;</span><span class="p">)</span>
        
        <span class="kn">from</span> <span class="nn">gblearn.base</span> <span class="k">import</span> <span class="n">nprocs</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;RDF&quot;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">collection</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">rcut</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">nprocs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span>
            <span class="n">mpool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)</span>
            <span class="n">compute</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_multiproc_execute</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">catom</span><span class="p">)))</span>
                       <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">collection</span><span class="p">]</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">compute</span><span class="p">):</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ctype</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">collection</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dfs</span></div>
        
<div class="viewcode-block" id="DFCollection.from_file"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.from_file">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a DFCollection from file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): path to the file that was created by</span>
<span class="sd">              :meth:`DF.save`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">load</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DFCollection</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="DFCollection.from_dict"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a DFCollection from a serialized dict (i.e., one returned by</span>
<span class="sd">        :meth:`serialize`).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (dict): result of calling :meth:`serialize`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">decomposer</span> <span class="o">=</span> <span class="n">SOAPDecomposer</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">dfdata</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dfs&quot;</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DF</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dfdata</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="c1">#We default to radial distributions.</span>
            <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">RDFCollection</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;counts&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ADFCollection</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;counts&quot;</span><span class="p">])</span>
        <span class="n">result</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tags&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="DFCollection.serialize"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.serialize">[docs]</a>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">withdP</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a serializable dictionary that represents this DFCollection.</span>

<span class="sd">        Args:</span>
<span class="sd">            withdP (bool): when True, the large, SOAP decomposition from which the</span>
<span class="sd">              DF was constructed is also included. Wasteful, but necessary to</span>
<span class="sd">              completely represent the DF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decomposer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">decomposer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decomposer</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
            
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">withdecomp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">commonx</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">withdP</span><span class="o">=</span><span class="n">withdP</span><span class="p">))</span>
            
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;dfs&quot;</span><span class="p">:</span> <span class="n">dfs</span><span class="p">,</span>
            <span class="s2">&quot;counts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="s2">&quot;tags&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">decomposer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decomposer</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>            
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="DFCollection.save"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">withdP</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the DF to disk.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (str): path to save the vector to.</span>
<span class="sd">            withdP (bool): when True, the large, SOAP decomposition from which the</span>
<span class="sd">              DF was constructed is also included. Wasteful, but necessary to</span>
<span class="sd">              completely represent the DF.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">dump</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">withdP</span><span class="o">=</span><span class="n">withdP</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the averaged radial distribution function for the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">df</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average</span>

<div class="viewcode-block" id="DFCollection.project"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">epsilon_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Projects the RDFs in self into the unique RDFs of other.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: (:class:`numpy.ndarray` projection, `list`</span>
<span class="sd">            exceptions); `projection` is the number of each kind of</span>
<span class="sd">            RDF in other with `sum(result) == len(self)`; `exceptions`</span>
<span class="sd">            are indices in `self` for which there was no similar :class:`DF` in</span>
<span class="sd">            other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">exceptions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">oi</span><span class="p">,</span> <span class="n">bdf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">bdf</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exceptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DFCollection.refine"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.refine">[docs]</a>    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">epsilon_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Refines this DFCollection to include all DFs in `other` that are not</span>
<span class="sd">        already in `self`. Also reduces existing DFs in `self` to be unique.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DFCollection): another collection to augment this one with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only refine collections of the same type.&quot;</span><span class="p">)</span>

        <span class="c1">#Make a copy of the distribution functions in self; make sure they are</span>
        <span class="c1">#unique to begin with.</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">epsilon_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xdf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">xdf</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">):</span>
                    <span class="n">dfs</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">io</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#We don&#39;t use :meth:`add` here because we have already</span>
                <span class="c1">#checked uniqueness and we want to keep the number of</span>
                <span class="c1">#identical DFs accurate.</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">io</span><span class="p">])</span>

        <span class="n">dfs</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dfs</span><span class="o">.</span><span class="n">_unique</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">dfs</span></div>
        
<div class="viewcode-block" id="DFCollection.histogram"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.histogram">[docs]</a>    <span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines how many of each kind of DF are in this collection (using</span>
<span class="sd">        the default comparison). Plots the histogram of unique values. This is</span>
<span class="sd">        equivalent to calling :meth:`DFCollection.unique.histogram`.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsilon_ (float): override the global (default) value</span>
<span class="sd">              :data:`~gblearn.decomposition.epsilon` for determining if the DFs</span>
<span class="sd">              are similar.</span>
<span class="sd">            kwargs (dict): arguments will be passed directly to</span>
<span class="sd">              :func:`matplotlib.pyplot.bar` for the plotting.</span>
<span class="sd">        Returns:</span>
<span class="sd">            DFCollection: of the unique values; same result as</span>
<span class="sd">              :meth:`DFCollection.unique`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">epsilon_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
            
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">total</span><span class="p">)</span>
        <span class="n">htitle</span> <span class="o">=</span> <span class="s2">&quot;Histogram of Unique DFs in Collection (</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">)&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">htitle</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">total</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;DF Number&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Percentage of Identical DFs &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">savefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">savefile</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">gblearn.base</span> <span class="k">import</span> <span class="n">testmode</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">testmode</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>       </div>
        
<div class="viewcode-block" id="DFCollection.unique"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.unique">[docs]</a>    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns only the unique DFs in this collection.</span>

<span class="sd">        Args:</span>
<span class="sd">            epsilon_ (float): override the global (default) value</span>
<span class="sd">              :data:`~gblearn.decomposition.epsilon` for determining if the DFs</span>
<span class="sd">              are similar.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DFCollection: of unique DFs within the specified tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#Construct a new, empty collection.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kept</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">kept</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">):</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">si</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">si</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#We want the return type to be the same as the current instance (radial</span>
        <span class="c1">#or angular).</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_unique</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>
        
<div class="viewcode-block" id="DFCollection.plot"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">xlabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">withavg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the collection of DFs on the same axes. Opacity of the line is</span>
<span class="sd">        chosen based on how many DFs in the collection are identical to that</span>
<span class="sd">        one (within tolerance). This is accomplished by calling</span>
<span class="sd">        :meth:`DFCollection.histogram`.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax (matplotlib.axes.Axes): axes to plot on. If not specified, a new</span>
<span class="sd">              figure and new axes will be created.</span>
<span class="sd">            savefile (str): path to a file if the figure should be saved.</span>
<span class="sd">            shells (list): of `float` values for neighbor shells to be added as</span>
<span class="sd">              vertical lines to the plot.</span>
<span class="sd">            color: any color option received by :func:`matplotlib.pyplot.plot`.</span>
<span class="sd">            title (str): override the default title of the plot.</span>
<span class="sd">            xlabel (str): override the default (generic, not very helpful) label for</span>
<span class="sd">              the x-axis.</span>
<span class="sd">            ylabel (str): override the default label for the y-axis.</span>
<span class="sd">            withavg (bool): when True, the average DF for the whole collection is also</span>
<span class="sd">              plotted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">axset</span><span class="o">=</span><span class="n">plt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axset</span><span class="o">=</span><span class="n">ax</span>

        <span class="n">cmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">))</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
        <span class="n">nalpha</span> <span class="o">=</span> <span class="mf">0.85</span> <span class="k">if</span> <span class="n">cmax</span><span class="o">/</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mf">0.33</span> <span class="k">else</span> <span class="mf">0.65</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">):</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">nalpha</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">di</span><span class="p">]</span><span class="o">/</span><span class="n">cmax</span>
            <span class="n">axset</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">maxy_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">maxy_</span> <span class="o">&gt;</span> <span class="n">maxy</span><span class="p">:</span>
                <span class="n">maxy</span> <span class="o">=</span> <span class="n">maxy_</span>

        <span class="k">if</span> <span class="n">withavg</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
            <span class="n">axset</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">average</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
            <span class="n">maxy_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">average</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">maxy_</span> <span class="o">&gt;</span> <span class="n">maxy</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
                <span class="n">maxy</span> <span class="o">=</span> <span class="n">maxy_</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;Ang.&quot;</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span> <span class="k">else</span> <span class="s2">&quot;Rad.&quot;</span>
            <span class="n">tstr</span> <span class="o">=</span> <span class="s2">&quot;Radial&quot;</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span> <span class="k">else</span> <span class="s2">&quot;Angular&quot;</span>
        <span class="k">else</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;unknown units&quot;</span>
            <span class="n">tstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> Distribution Function of Collection&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tstr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xlabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Distance (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Accumulated Density&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>

        <span class="n">_plot_shells</span><span class="p">(</span><span class="n">axset</span><span class="p">,</span> <span class="n">shells</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">savefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">savefile</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">gblearn.base</span> <span class="k">import</span> <span class="n">testmode</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">testmode</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">axset</span></div>
    
<div class="viewcode-block" id="DFCollection.add"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new DF to the collection.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (DF): instance to add; if it is already in the collection, nothing</span>
<span class="sd">              will happen.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">DF</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only DF objects can be added to DF collections.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">df</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;Only DFs of type </span><span class="si">{}</span><span class="s2">DF can be added to this collection.&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        
        <span class="n">do_add</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">:</span>
            <span class="c1">#We need to make sure that the DF is unique before adding it.</span>
            <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xdf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">xdf</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">df</span><span class="p">):</span><span class="c1"># pragma: no cover</span>
                    <span class="c1">#I can&#39;t seem to get this line to log, no matter what I</span>
                    <span class="c1">#throw at it...</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">do_add</span> <span class="o">=</span> <span class="kc">True</span>    
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">df</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">:</span>
                <span class="n">do_add</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">do_add</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_average</span> <span class="o">=</span> <span class="kc">None</span></div>
        
<div class="viewcode-block" id="DFCollection.remove"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.DFCollection.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove an DF from the collection.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rdf (DF): instance to remove; if it isn&#39;t already in the</span>
<span class="sd">              collection, nothing will happen.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">DF</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">df</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">:</span>
            <span class="n">idf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">idf</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_average</span> <span class="o">=</span> <span class="kc">None</span></div></div>

<span class="k">def</span> <span class="nf">_multiproc_execute</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span><span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Executes the instance method on the given object.</span>

<span class="sd">    Args:</span>
<span class="sd">        obj: object to execute the method on.</span>
<span class="sd">        method (str): name of the method to execute.</span>
<span class="sd">        args (tuple): arguments to pass; method called as obj.method(*args).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#We don&#39;t cover this because it won&#39;t necessarily be caught be the coverage</span>
    <span class="c1">#program that is running on the main thread; it may only execute on other</span>
    <span class="c1">#threads.</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            
<div class="viewcode-block" id="RDFCollection"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.RDFCollection">[docs]</a><span class="k">class</span> <span class="nc">RDFCollection</span><span class="p">(</span><span class="n">DFCollection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a radial distribution function collection. See also the</span>
<span class="sd">    comments for :class:`DFCollection`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="RDFCollection.from_soap"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.RDFCollection.from_soap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_soap</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an RDF collection from the specified SOAPVector collection</span>
<span class="sd">        using the :math:`l&gt;0` components.</span>

<span class="sd">        Args:</span>
<span class="sd">            collection (SOAPVectorCollection): collection of SOAP vectors to</span>
<span class="sd">              initialize from.</span>
<span class="sd">            resolution (int): number of points to sample in the radial domain.</span>
<span class="sd">            catom (bool): when True, the DFs are constructed using the density of</span>
<span class="sd">              the central atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="n">DFCollection</span><span class="o">.</span><span class="n">dfs_from_soap</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="s2">&quot;RDF&quot;</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">catom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RDFCollection</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="ADFCollection"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.ADFCollection">[docs]</a><span class="k">class</span> <span class="nc">ADFCollection</span><span class="p">(</span><span class="n">DFCollection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a collection of Angular Distrubition Functions.  See also the</span>
<span class="sd">    comments for :class:`DFCollection`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ADFCollection.from_soap"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.ADFCollection.from_soap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_soap</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an ADF collection from the specified SOAPVector collection</span>
<span class="sd">        using the :math:`l&gt;0` components.</span>

<span class="sd">        Args:</span>
<span class="sd">            collection (SOAPVectorCollection): collection of SOAP vectors to</span>
<span class="sd">              initialize from.</span>
<span class="sd">            resolution (int): number of points to sample in the angular domain.</span>
<span class="sd">            catom (bool): when True, the DFs are constructed using the density of</span>
<span class="sd">              the central atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#We only have degrees of freedom in the polar angle; the azimuthal got</span>
        <span class="c1">#average out to give us rotational invarance.</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="n">DFCollection</span><span class="o">.</span><span class="n">dfs_from_soap</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="s2">&quot;ADF&quot;</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">catom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ADFCollection</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span></div></div>
    
<div class="viewcode-block" id="SOAPVector"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector">[docs]</a><span class="k">class</span> <span class="nc">SOAPVector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for a SOAP vector that facilitates decomposition, plotting and</span>
<span class="sd">    analysis in the SOAP space.</span>

<span class="sd">    Args:</span>
<span class="sd">        P (numpy.ndarray): vector representing the projection of a local atomic</span>
<span class="sd">          environment into the SOAP space.</span>
<span class="sd">        decomposer (SOAPDecomposer): instance used to decompose the SOAP vector; has</span>
<span class="sd">          configuration information for SOAP parameters and caches for rapid</span>
<span class="sd">          evaluation of the basis functions.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        dnP (list): of tuples; result of calling</span>
<span class="sd">          :func:`gblearn.decomposition.pissnnl` on the SOAP vector with `l=0`</span>
<span class="sd">          components set to zero.</span>
<span class="sd">        dcP (list): of tuples; result of calling</span>
<span class="sd">          :func:`gblearn.decomposition.pissnnl` on the SOAP vector with `l&gt;0`</span>
<span class="sd">          components set to zero.</span>
<span class="sd">        nP (numpy.ndarray): a copy of `P` with `l=0` components set to zero.</span>
<span class="sd">        cP (numpy.ndarray): a copy of `P` with `l&gt;0` components set to zero.</span>
<span class="sd">        rx (numpy.ndarray): sample points in the radial domain at which :attr:`cRDF`</span>
<span class="sd">          and :attr:`nRDF` were sampled.</span>
<span class="sd">        cRDF (DF): radial distribution function for the central atom.</span>
<span class="sd">        nRDF (DF): radial distribution function for all the neighbors of the</span>
<span class="sd">          central atom.</span>
<span class="sd">        rx (numpy.ndarray): sample points in the angular domain at which</span>
<span class="sd">          :attr:`cADF` and :attr:`nADF` were sampled.</span>
<span class="sd">        cADF (DF): angular distribution function for the central atom.</span>
<span class="sd">        nADF (DF): angular distribution function for all the neighbors of the</span>
<span class="sd">          central atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cP</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nP</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span> <span class="o">=</span> <span class="n">decomposer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dcP</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dnP</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: cached value of the radial values that we evaluated</span>
<span class="sd">        the RDF at; useful if the RDF is requested repeatedly for the same `r`</span>
<span class="sd">        values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cRDF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: cached values of the RDF for the cached</span>
<span class="sd">        value in :attr:`rx` with :math:`l=0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nRDF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: cached values of the RDF for the cached</span>
<span class="sd">        value in :attr:`rx` with :math:`l&gt;0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: cached value of the angular values that we evaluated</span>
<span class="sd">        the ADF at; useful if the ADF is requested repeatedly for the same</span>
<span class="sd">        `theta` values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cADF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: cached values of the ADF for the cached</span>
<span class="sd">        value in :attr:`ax` with :math:`l=0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nADF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;numpy.ndarray: cached values of the ADF for the cached</span>
<span class="sd">        value in :attr:`ax` with :math:`l&gt;0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests equality between two SOAP vectors by comparing *only*</span>
<span class="sd">        their P vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">P</span><span class="p">)</span>

<div class="viewcode-block" id="SOAPVector.equal"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs a more thorough equality check by also comparing</span>
<span class="sd">        the SOAP decomposers and RDFs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Pok</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
        <span class="n">Dok</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">rx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Rok</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">rx</span><span class="p">)</span> <span class="ow">and</span>
                       <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">cRDF</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">cRDF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cRDF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">other</span><span class="o">.</span><span class="n">cRDF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cRDF</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">cRDF</span><span class="o">.</span><span class="n">df</span><span class="p">)))</span> <span class="ow">and</span>
                       <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nRDF</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">nRDF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRDF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">other</span><span class="o">.</span><span class="n">nRDF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRDF</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nRDF</span><span class="o">.</span><span class="n">df</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
                <span class="n">Rok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Rok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Aok</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span> <span class="ow">and</span>
                       <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">cADF</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">cADF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cADF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">other</span><span class="o">.</span><span class="n">cADF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cADF</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">cADF</span><span class="o">.</span><span class="n">df</span><span class="p">)))</span> <span class="ow">and</span>
                       <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nADF</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">nADF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nADF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">other</span><span class="o">.</span><span class="n">nADF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nADF</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nADF</span><span class="o">.</span><span class="n">df</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
                <span class="n">Aok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Aok</span> <span class="o">=</span> <span class="kc">True</span>
            
        <span class="k">return</span> <span class="n">Pok</span> <span class="ow">and</span> <span class="n">Dok</span> <span class="ow">and</span> <span class="n">Rok</span> <span class="ow">and</span> <span class="n">Aok</span></div>
    
<div class="viewcode-block" id="SOAPVector.from_element"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.from_element">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_element</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the SOAP vector for a pure element.</span>

<span class="sd">        Args:</span>
<span class="sd">            element (str): element name. Must be one of </span>
<span class="sd">              [&quot;Ni&quot;, &quot;Cr&quot;, &quot;Mg&quot;].</span>
<span class="sd">            index (int): for multi-atom bases, which atom to represent</span>
<span class="sd">              in the elemental crystal.</span>
<span class="sd">            nmax (int): bandwidth limits for the SOAP descriptor radial basis</span>
<span class="sd">              functions.</span>
<span class="sd">            lmax (int): bandwidth limits for the SOAP descriptor spherical</span>
<span class="sd">              harmonics.</span>
<span class="sd">            rcut (float): local environment finite cutoff parameter.</span>
<span class="sd">            sigma (float): width parameter for the Gaussians on each atom.</span>
<span class="sd">            trans_width (float): distance over which the coefficients in the</span>
<span class="sd">                radial functions are smoothly transitioned to zero.    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">gblearn.elements</span> <span class="k">import</span> <span class="n">pissnnl</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">pissnnl</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">decomposer</span> <span class="o">=</span> <span class="n">SOAPDecomposer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SOAPVector</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SOAPVector.from_file"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.from_file">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">decomposer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a SOAP vector from file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): path to the file that was created by</span>
<span class="sd">              :meth:`SOAPVector.save`.</span>
<span class="sd">            decomposer (SOAPDecomposer): if this serialization was part of a</span>
<span class="sd">              higher level collection, then the decomposer would not have been</span>
<span class="sd">              included at the item level. For reconstruction, it is passed in by</span>
<span class="sd">              the collection.</span>
<span class="sd">            rx (numpy.ndarray): as for `decomposer`, but with the values in the</span>
<span class="sd">              domain.</span>
<span class="sd">            ax (numpy.ndarray): as for `decomposer`, but with the angular values</span>
<span class="sd">              in the domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">load</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SOAPVector</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOAPVector.from_dict"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">decomposer_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a SOAP vector from a serialized dict (i.e., one returned by</span>
<span class="sd">        :meth:`serialize`).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (dict): result of calling :meth:`serialize`.</span>
<span class="sd">            decomposer_ (SOAPDecomposer): if this serialization was part of a</span>
<span class="sd">              higher level collection, then the decomposer would not have been</span>
<span class="sd">              included at the item level. For reconstruction, it is passed in by</span>
<span class="sd">              the collection.</span>
<span class="sd">            rx (numpy.ndarray): as for `decomposer`, but with the values in the</span>
<span class="sd">              domain.</span>
<span class="sd">            ax (numpy.ndarray): as for `decomposer`, but with the angular values</span>
<span class="sd">              in the domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">decomposer_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">decomposer</span> <span class="o">=</span> <span class="n">decomposer_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">decomposer</span> <span class="o">=</span> <span class="n">SOAPDecomposer</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">])</span>
            
        <span class="n">result</span> <span class="o">=</span> <span class="n">SOAPVector</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">],</span> <span class="n">decomposer</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">dcP</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dcP&quot;</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">dnP</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dnP&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rx&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="n">result</span><span class="o">.</span><span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">rx</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rx&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="c1"># pragma: no cover</span>
            <span class="n">result</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cRDF&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">cRDF</span> <span class="o">=</span> <span class="n">DF</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dcP&quot;</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span>
                             <span class="n">calculate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">cRDF</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cRDF&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nRDF&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">nRDF</span> <span class="o">=</span> <span class="n">DF</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dnP&quot;</span><span class="p">],</span> <span class="kc">False</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span>
                             <span class="n">calculate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">nRDF</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nRDF&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cADF&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">cADF</span> <span class="o">=</span> <span class="n">DF</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dcP&quot;</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span>
                             <span class="n">calculate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">cADF</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cADF&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nADF&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">nADF</span> <span class="o">=</span> <span class="n">DF</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dnP&quot;</span><span class="p">],</span> <span class="kc">False</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span>
                             <span class="n">calculate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">nADF</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nADF&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="SOAPVector.serialize"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.serialize">[docs]</a>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">withdecomp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">commonrx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">withdP</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">commonax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a serializable dictionary that represents this SOAP Vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            withdecomp (bool): when True, include the parameters of the SOAP</span>
<span class="sd">              decomposer in the dict.</span>
<span class="sd">            commonrx (numpy.ndarray): xf this DF is part of a collection, the radial</span>
<span class="sd">              values will be the same for every DF; in that case we don&#39;t need to</span>
<span class="sd">              include the domain in the serialization. This is the parent</span>
<span class="sd">              collections common radial vector. If the DFs is the same, it won&#39;t</span>
<span class="sd">              be serialized. If unspecified, the domain values are serialized.</span>
<span class="sd">            withdP (bool): when True, the large, decomposed SOAP vector values are</span>
<span class="sd">              serialized. Necessary to completely reconstruct the representation,</span>
<span class="sd">              but not necessary for most analysis.</span>
<span class="sd">            commonax (numpy.ndarray): same as for `commonrx` but for the angular</span>
<span class="sd">              domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span>
            <span class="s2">&quot;dcP&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dcP</span> <span class="k">if</span> <span class="n">withdP</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;dnP&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnP</span> <span class="k">if</span> <span class="n">withdP</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;rx&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;ax&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;cRDF&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;nRDF&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;cADF&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;nADF&quot;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">withdecomp</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">commonrx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">commonrx</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s2">&quot;rx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">commonax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">commonax</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span>
                
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cRDF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;cRDF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cRDF</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRDF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;nRDF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRDF</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cADF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;cADF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cADF</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nADF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;nADF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nADF</span><span class="o">.</span><span class="n">df</span>

        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="SOAPVector.save"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the SOAP vector to disk so that RDF and decomposition</span>
<span class="sd">        operations don&#39;t have to be re-executed later.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (str): path to save the vector to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">dump</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_DF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dfname</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the specified distribution function, taking the cache into</span>
<span class="sd">        account.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (numpy.ndarray): values in the radial or angular domain to sample</span>
<span class="sd">              at.</span>
<span class="sd">            dfname (str): name of the attribute on `self` corresponding to the</span>
<span class="sd">              cached distribution function to consider before </span>
<span class="sd">              constructing a new one. *Modified* by this routine if a DF is</span>
<span class="sd">              constructed.</span>
<span class="sd">            xname (str): name of attribute on `self` corresponding to cached</span>
<span class="sd">              sample values to consider before</span>
<span class="sd">              constructing a new :class:`DF`. *Modified* by this routine if a DF</span>
<span class="sd">              is constructed.</span>
<span class="sd">            catom (bool): when True, consider the central atom&#39;s distribution</span>
<span class="sd">              function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">allclose</span>
        <span class="n">cachex</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xname</span><span class="p">)</span>
        <span class="n">cacheDF</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfname</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">cachex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cachex</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="ow">and</span> <span class="n">allclose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cachex</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">cacheDF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cacheDF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">dP</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">catom</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cP</span>
            <span class="n">dP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dcP</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nP</span>
            <span class="n">dP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnP</span>
            
        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lrest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">partition</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">catom</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">P</span><span class="p">[</span><span class="n">lrest</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="n">catom</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cP</span> <span class="o">=</span> <span class="n">P</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nP</span> <span class="o">=</span> <span class="n">P</span>
            
        <span class="k">if</span> <span class="n">dP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">catom</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dcP</span> <span class="o">=</span> <span class="n">dP</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dnP</span> <span class="o">=</span> <span class="n">dP</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfname</span><span class="p">,</span> <span class="n">DF</span><span class="p">(</span><span class="n">dP</span><span class="p">,</span> <span class="n">catom</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="p">,</span> <span class="n">xname</span><span class="o">==</span><span class="s2">&quot;rx&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dfname</span><span class="p">)</span>
            
<div class="viewcode-block" id="SOAPVector.ADF"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.ADF">[docs]</a>    <span class="k">def</span> <span class="nf">ADF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angular distribution function for the SOAP vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax (numpy.ndarray): domain in the angular space to evaluate the ADF</span>
<span class="sd">              at.</span>
<span class="sd">            catom (bool): when True, the ADF of the central atom is returned;</span>
<span class="sd">              otherwise, the central atom is ignored and the neighbor ADF is</span>
<span class="sd">              returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">catom</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_DF</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;cADF&quot;</span><span class="p">,</span> <span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_DF</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;nADF&quot;</span><span class="p">,</span> <span class="s2">&quot;ax&quot;</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="SOAPVector.RDF"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVector.RDF">[docs]</a>    <span class="k">def</span> <span class="nf">RDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the *total* radial distribution function for the SOAP vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            rx (numpy.ndarray): domain in the radial space to evaluate the RDF</span>
<span class="sd">              at.</span>
<span class="sd">            catom (bool): when True, the RDF of the central atom is returned;</span>
<span class="sd">              otherwise, the central atom is ignored and the neighbor RDF is</span>
<span class="sd">              returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">catom</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_DF</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="s2">&quot;cRDF&quot;</span><span class="p">,</span> <span class="s2">&quot;rx&quot;</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_DF</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="s2">&quot;nRDF&quot;</span><span class="p">,</span> <span class="s2">&quot;rx&quot;</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="SOAPVectorCollection"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection">[docs]</a><span class="k">class</span> <span class="nc">SOAPVectorCollection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a collection of SOAP vectors that are logically combined (for</span>
<span class="sd">    example the local environments at a grain boundary are all part of the grain</span>
<span class="sd">    boundary). The collection allows aggregate quantities to be calculated more</span>
<span class="sd">    easily.</span>

<span class="sd">    Args:</span>
<span class="sd">        Pij (numpy.ndarray): a matrix of SOAP vectors, where each *row* is a</span>
<span class="sd">          vector.</span>
<span class="sd">        decomposer (SOAPDecomposer): instance used to decompose the SOAP</span>
<span class="sd">          vectors; has configuration information for SOAP parameters and caches</span>
<span class="sd">          for rapid evaluation of the basis functions.</span>
<span class="sd">        calculate (bool): when True, the SOAPVectors are calculated based on `P`;</span>
<span class="sd">          otherwise, they are left as an empty list.</span>
<span class="sd">        kwargs (dict): arguments that can be passed to :class:`SOAPDecomposer`</span>
<span class="sd">          constuctor.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Create a collection of SOAP vectors and then collapse them into a set of</span>
<span class="sd">        unique ones (an instance of :class:`RDFCollection`).</span>

<span class="sd">        &gt;&gt;&gt; from gblearn.decomposition import SOAPVectorCollection as SVC</span>
<span class="sd">        &gt;&gt;&gt; from numpy import load</span>
<span class="sd">        &gt;&gt;&gt; P = load(&quot;pissnnl.npy&quot;)</span>
<span class="sd">        &gt;&gt;&gt; svc = SVC(P, lmax=18, nmax=18)</span>
<span class="sd">        &gt;&gt;&gt; urdfs = svc.unique(rdf=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Pij</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decomposer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">calculate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">Pij</span>
        <span class="k">if</span> <span class="n">decomposer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span> <span class="o">=</span> <span class="n">SOAPDecomposer</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span> <span class="o">=</span> <span class="n">decomposer</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">calculate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">SOAPVector</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="p">)</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;dict: keys are `int` sampling resolutions; values are *unique* RDFs</span>
<span class="sd">        (:class:`RDFCollection`) in this :class:`SOAPVectorCollection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;dict: keys are `int` sampling resolutions; values are *unique* ADFs</span>
<span class="sd">        (:class:`ADFCollection`) in this :class:`SOAPVectorCollection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>        

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">a</span><span class="o">==</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">vectors</span><span class="p">)])</span>
<div class="viewcode-block" id="SOAPVectorCollection.equal"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs a more rigorous equality test for two collections by *also*</span>
<span class="sd">        comparing the radial and angular distribution functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_rdfs</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_adfs</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">SOAPVectorCollection</span><span class="p">(</span><span class="n">decomposer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">index</span><span class="p">,:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">dfs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">dfs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">dfs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">dfs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">SOAPVector</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only SOAPVectors can be placed in an SOAP &quot;</span>
                            <span class="s2">&quot;vector collection.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="SOAPVectorCollection.from_file"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection.from_file">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a SOAPVectorCollection from file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): path to the file that was created by</span>
<span class="sd">              :meth:`SOAPVectorCollection.save`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">load</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SOAPVectorCollection</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOAPVectorCollection.from_dict"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restores a SOAPVectorCollection from a serialized dict (i.e., one</span>
<span class="sd">        returned by :meth:`serialize`).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (dict): result of calling :meth:`serialize`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">decomposer</span> <span class="o">=</span> <span class="n">SOAPDecomposer</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;decomposer&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vectors&quot;</span><span class="p">]:</span>
            <span class="n">nvec</span> <span class="o">=</span> <span class="n">SOAPVector</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">decomposer</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rx&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">])</span>
            <span class="n">vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nvec</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">SOAPVectorCollection</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">],</span> <span class="n">decomposer</span><span class="p">,</span> <span class="n">calculate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">vectors</span> <span class="o">=</span> <span class="n">vecs</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_rdfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">RDFCollection</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;RDFs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_adfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">ADFCollection</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ADFs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="SOAPVectorCollection.serialize"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection.serialize">[docs]</a>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">withdP</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a serializable dictionary that represents this</span>
<span class="sd">        :class:`SOAPVectorCollection`.</span>

<span class="sd">        Args:</span>
<span class="sd">            withdP (bool): when True, the large, SOAP decomposition from which the</span>
<span class="sd">              DFs are constructed is also included. Wasteful, but necessary to</span>
<span class="sd">              completely represent the DFs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rx</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="n">vecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectors</span><span class="p">:</span>
            <span class="n">vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">withdP</span><span class="p">,</span> <span class="n">ax</span><span class="p">))</span>
            
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;decomposer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposer</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span>
            <span class="s2">&quot;vectors&quot;</span><span class="p">:</span> <span class="n">vecs</span><span class="p">,</span>
            <span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span>
            <span class="s2">&quot;RDFs&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">dfcol</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">withdP</span><span class="o">=</span><span class="n">withdP</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">dfcol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="s2">&quot;ADFs&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">dfcol</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">withdP</span><span class="o">=</span><span class="n">withdP</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">dfcol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="s2">&quot;rx&quot;</span><span class="p">:</span> <span class="n">rx</span><span class="p">,</span>
            <span class="s2">&quot;ax&quot;</span><span class="p">:</span> <span class="n">ax</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="SOAPVectorCollection.save"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">withdP</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the DF to disk.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (str): path to save the vector to.</span>
<span class="sd">            withdP (bool): when True, the large, SOAP decomposition from which the</span>
<span class="sd">              DF was constructed is also included. Wasteful, but necessary to</span>
<span class="sd">              completely represent the DF.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">six.moves.cPickle</span> <span class="k">import</span> <span class="n">dump</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">withdP</span><span class="o">=</span><span class="n">withdP</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SOAPVectorCollection.RDFs"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection.RDFs">[docs]</a>    <span class="k">def</span> <span class="nf">RDFs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the set of *unique* radial distribution functions for this</span>
<span class="sd">        collection.</span>

<span class="sd">        Args:</span>
<span class="sd">            resolution (int): number of points to sample in the radial domain.</span>
<span class="sd">            catom (bool): when True, the DFs are constructed using the density of</span>
<span class="sd">              the central atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span><span class="p">[</span><span class="n">resolution</span><span class="p">]</span> <span class="o">=</span> <span class="n">RDFCollection</span><span class="o">.</span><span class="n">from_soap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">catom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdfs</span><span class="p">[</span><span class="n">resolution</span><span class="p">]</span>  </div>

<div class="viewcode-block" id="SOAPVectorCollection.ADFs"><a class="viewcode-back" href="../../Modules/gblearn.decomposition.html#gblearn.decomposition.SOAPVectorCollection.ADFs">[docs]</a>    <span class="k">def</span> <span class="nf">ADFs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">catom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the set of *unique* angular distribution functions for this</span>
<span class="sd">        collection.</span>

<span class="sd">        Args:</span>
<span class="sd">            resolution (int): number of points to sample in the angular domain.</span>
<span class="sd">            catom (bool): when True, the DFs are constructed using the density of</span>
<span class="sd">              the central atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span><span class="p">[</span><span class="n">resolution</span><span class="p">]</span> <span class="o">=</span> <span class="n">ADFCollection</span><span class="o">.</span><span class="n">from_soap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">catom</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adfs</span><span class="p">[</span><span class="n">resolution</span><span class="p">]</span>  </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">gblearn 0.2.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Conrad W. Rosenbrock.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>